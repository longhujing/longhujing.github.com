<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GitBash 主题</title>
      <link href="2020/11/03/4dbe01c1.html"/>
      <url>2020/11/03/4dbe01c1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Windows安装的GitBash初始的时候丑的一比，对于我这种追究外表、爱捣鼓一些乱七八糟玩意的人是无法接受的😂</p></blockquote><h2 id="设置GitBash主题"><a href="#设置GitBash主题" class="headerlink" title="设置GitBash主题"></a>设置GitBash主题</h2><div class="note info simple"><p>打开<code>GitBash</code>，输入命令<code>vim ~/.minttyrc</code></p></div><h3 id="主题1"><a href="#主题1" class="headerlink" title="主题1"></a>主题1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BoldAsFont&#x3D;-1</span><br><span class="line">FontHeight&#x3D;12</span><br><span class="line">Scrollbar&#x3D;none</span><br><span class="line">Term&#x3D;xterm-256color</span><br><span class="line">BoldAsColour&#x3D;yes</span><br><span class="line">Black&#x3D;7,54,66</span><br><span class="line">Red&#x3D;220,50,47</span><br><span class="line">Green&#x3D;133,153,0</span><br><span class="line">Yellow&#x3D;181,137,0</span><br><span class="line">Blue&#x3D;38,139,210</span><br><span class="line">Magenta&#x3D;211,54,130</span><br><span class="line">Cyan&#x3D;42,161,152</span><br><span class="line">White&#x3D;238,232,213</span><br><span class="line">BoldBlack&#x3D;0,43,54</span><br><span class="line">BoldRed&#x3D;203,75,22</span><br><span class="line">BoldGreen&#x3D;88,110,117</span><br><span class="line">BoldYellow&#x3D;101,123,131</span><br><span class="line">BoldBlue&#x3D;131,148,150</span><br><span class="line">BoldMagenta&#x3D;108,113,196</span><br><span class="line">BoldCyan&#x3D;147,161,161</span><br><span class="line">BoldWhite&#x3D;253,246,227</span><br><span class="line">ForegroundColour&#x3D;192,192,192</span><br><span class="line">BackgroundColour&#x3D;0,43,54</span><br><span class="line">CursorColour&#x3D;133,153,0</span><br><span class="line">Columns&#x3D;140</span><br><span class="line">Rows&#x3D;40</span><br><span class="line"></span><br><span class="line">Locale&#x3D;zh_CN</span><br><span class="line">Charset&#x3D;UTF-8</span><br><span class="line">Font&#x3D;YaHei Consolas Hybrid</span><br><span class="line">Transparency&#x3D;off</span><br><span class="line">CursorType&#x3D;block</span><br><span class="line">CursorBlinks&#x3D;yes</span><br></pre></td></tr></table></figure><p>效果就是这样啦</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201103014402.jpg"></p><h3 id="主题2"><a href="#主题2" class="headerlink" title="主题2"></a>主题2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Font&#x3D;Consolas</span><br><span class="line">FontHeight&#x3D;9</span><br><span class="line"></span><br><span class="line">BackgroundColour&#x3D;216,230,206</span><br><span class="line">ForegroundColour&#x3D;0,0,0</span><br><span class="line">CursorColour&#x3D;0,0,0</span><br><span class="line">Black&#x3D;0,0,0</span><br><span class="line">BoldBlack&#x3D;0,0,0</span><br><span class="line">Red&#x3D;130,68,6</span><br><span class="line">BoldRed&#x3D;246,155,64</span><br><span class="line">Green&#x3D;6,130,68</span><br><span class="line">BoldGreen&#x3D;64,246,155</span><br><span class="line">Yellow&#x3D;68,130,6</span><br><span class="line">BoldYellow&#x3D;155,246,64</span><br><span class="line">Blue&#x3D;68,6,130</span><br><span class="line">BoldBlue&#x3D;155,64,246</span><br><span class="line">Magenta&#x3D;130,6,68</span><br><span class="line">BoldMagenta&#x3D;246,64,155</span><br><span class="line">Cyan&#x3D;6,68,130</span><br><span class="line">BoldCyan&#x3D;64,155,246</span><br><span class="line">White&#x3D;255,255,255</span><br><span class="line">BoldWhite&#x3D;255,255,255</span><br><span class="line"></span><br><span class="line">Columns&#x3D;120</span><br><span class="line">Rows&#x3D;34</span><br><span class="line">CursorType&#x3D;block</span><br><span class="line">BoldAsFont&#x3D;-1</span><br><span class="line">FontWeight&#x3D;400</span><br><span class="line">FontIsBold&#x3D;no</span><br></pre></td></tr></table></figure><p>效果就是这样啦~</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201103014439.png"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBash </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引失效</title>
      <link href="2020/10/29/90fd26f6.html"/>
      <url>2020/10/29/90fd26f6.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是失效"><a href="#什么是失效" class="headerlink" title="什么是失效"></a>什么是失效</h2><p>明明创建好了索引，但是执行的时候却没有时用到这个索引，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`demo_table`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> demo_table <span class="keyword">WHERE</span> a = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201029014815.png"></p><p>表中，<code>a</code>为主键列，案例来说应该使用到主键索引才对，但是实际上并没有</p><h2 id="什么时候会失效"><a href="#什么时候会失效" class="headerlink" title="什么时候会失效"></a>什么时候会失效</h2><p>索引失效一共有7种情况，分别是：</p><ol><li><code>LIKE</code>查询以<code>%</code>开头</li><li><code>WHERE</code>条件中的索引列参与了计算</li><li><code>WHERE</code>条件中的索引调用了函数</li><li>索引列需要进行类型转换</li><li>复合索引未能满足<code>最左匹配原则</code></li><li>使用了<code>OR</code></li><li><code>MySQL</code>觉得没有必要走索引</li></ol><h2 id="为什么会失效"><a href="#为什么会失效" class="headerlink" title="为什么会失效"></a>为什么会失效</h2><p>要弄明白为什么会失效，首先需要搞清楚<code>MySQL</code>的索引是什么，其底层的结构是什么样的以及<code>MySQL</code>到底是怎么通过索引来检索数据的。</p><p>MySQL中的索引主要是Hash索引和B+树索引，而InnoDB中的索引就是B+树索引。总所周知，MySQL的聚簇索引每个非叶子节点存储的其实是主键值，叶子节点存储的是整行的值，而且每行之间是根据主键进行排序的。二级索引的结构和聚簇索引差不多，叶子节点上存储的是索引列的值+主键，并且也是根据索引列+主键列进行排序。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031155759.png" alt="索引结构图"></p><p>对于聚簇索引而言，查询的时候就是通过主键列的值一个一个的比较过去就可以查到了，对于非聚簇索引，那么就需要<span style="color:red">依次</span>比较索引列的值，然后最终确定到一个或多个叶子节点，如果采用的是覆盖索引，那么就可以返回了，否则还需要根据主键值来一次回表查询。</p><p>为了说明问题，使用这张表进行演示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`demo_table`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">varchar</span>(<span class="number">32</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b_c_d`</span> (<span class="string">`b`</span>, <span class="string">`c`</span>, <span class="string">`d`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><h3 id="LIKE查询失效"><a href="#LIKE查询失效" class="headerlink" title="LIKE查询失效"></a>LIKE查询失效</h3><p>LIKE查询失效指的是以<code>%</code>开头的查询才会失效，并不是所有的都会失效，比如说这个LIKE就不会失效</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031164743.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031164846.png"></p><p>但是这么玩就会失效了</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031170818.png"></p><p>也就是说，如果LIKE查询是<code>%</code>开头，那么这个索引就用不上了。</p><p>之前说过索引的结构和查询使用的过程，是通过索引列一个一个比较的，<code>%</code>的意思是可以为任意长度的字符串，那这还怎么去比较呢？毕竟需要从头比较不是</p><h3 id="索引列参与了计算或使用了函数"><a href="#索引列参与了计算或使用了函数" class="headerlink" title="索引列参与了计算或使用了函数"></a>索引列参与了计算或使用了函数</h3><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031171302.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031172817.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031173933.png"></p><p>这种情况主要是因为参与计算或者使用了函数以后，本来应该是确定的值，现在不确定了！就好比第一张图，一眼看过去就知道结果是<code>b = &#39;12&#39;</code>，但是你不能要求MySQL跟你一样聪明啊，MySQL在这种情况下只能当作一个未知数来处理，一个未知数又怎么可能根据索引去做比较呢？</p><h3 id="索引列需要进行类型转换"><a href="#索引列需要进行类型转换" class="headerlink" title="索引列需要进行类型转换"></a>索引列需要进行类型转换</h3><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031174811.png"></p><p>类型转换的原因和之前的需要计算或者使用了函数的原因相同，单独列出来是为了着重说明，因为平时很容易忽略这个问题</p><h3 id="不满足最左匹配原则"><a href="#不满足最左匹配原则" class="headerlink" title="不满足最左匹配原则"></a>不满足最左匹配原则</h3><p>最左匹配原则的意思就是，从左往右匹配呗，比如现在有的索引是<code>idx_b_c_d</code>，然后比较的时候当然就是先比较<code>b</code>，然后比较<code>c</code>，最后比较<code>d</code>这样搞。</p><p>那么不满足最左匹配原则就是没有按照上述的规则来呗</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031175222.png"></p><p>像这样，虽然<code>c</code>和<code>d</code>都在索引<code>idx_b_c_d</code>中，但是由于没有用到<code>b</code>，导致从左往右匹配的时候无法进行，因此没有使用到索引</p><h3 id="使用了OR"><a href="#使用了OR" class="headerlink" title="使用了OR"></a>使用了OR</h3><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031175519.png"></p><p>按理来说，<code>b = &#39;2&#39; AND c = &#39;2&#39;</code>满足最左匹配原则，应该是可以使用到索引<code>idx_b_c_d</code>的，但是问题在于使用<code>b = &#39;2&#39; AND c = &#39;2&#39;</code>这个条件并不能囊括所有的可能数据，因为<code>c = 1</code>这一类的数据就没有被考虑进去，因此在这种情况下是无法使用索引的。</p><h3 id="MySQL觉得没必要走索引"><a href="#MySQL觉得没必要走索引" class="headerlink" title="MySQL觉得没必要走索引"></a>MySQL觉得没必要走索引</h3><p>之前说过二级索引的叶子节点存储的是二级索引的索引列值+主键值，如果查询的时候没有用到覆盖索引，那么就会根据主键值回表一次，这种情况下其实查询了一共2次索引</p><p>假设查询的代价是<code>n</code>，那么如果扫描一次全表的代价是<code>m</code>且<code>n &gt; m</code>的时候，MySQL就会选择走全表而不走索引了，毕竟走索引还不如走全表不是</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的日志</title>
      <link href="2020/10/18/937fe6d5.html"/>
      <url>2020/10/18/937fe6d5.html</url>
      
        <content type="html"><![CDATA[<p>MySQL操作数据的时候，每次是从磁盘中按页读取数据的，对这部分数据进行修改以后，首先会将修改放到一块内存区域<code>Buffer Pool</code>中，然后再刷到磁盘中。假如说此时发生了一些故障，比如突然断电，导致<code>Buffer Pool</code>中的一些数据还没有来得及刷到磁盘上，那不就丢失了整个<code>Buffer Pool</code>的数据？</p><p>为了避免这种情况，MySQL采用了一种<code>WAL(Write Ahead Log)</code>机制，即预写日志机制，其核心就是刷新内存之前，先把日志记录到磁盘里面永久保存，而且为了提升性能，写日志都是顺序IO。</p><p>MySQL中的日志大致有7种类型，分别是</p><p><code>redo log</code>、<code>undo log</code>、<code>bin log</code>、<code>error log</code>、<code>slow query log</code>、<code>general log</code>、<code>relay log</code></p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>有这么一种情况，一个事务已经<code>commit</code>了，但是还没有把数据刷新到磁盘，此时突然发生故障，导致这一部分数据丢失，为了让MySQL重启以后恢复到原来的状态，就需要使用<code>redo log</code>。</p><h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p>和<code>Buffer Pool</code>一样，redo log也有自己的一个缓冲池<code>redo log buffer</code>，事务执行<code>DML</code>语句的时候，会向<code>redo log buffer</code>中记录一条修改的日志，然后刷新到磁盘上的日志文件中去。</p><p>默认的，<code>redo log buffer</code>的大小是<code>16M</code>（MySQL 8.0），可以通过如下命令查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| Variable_name          | Value    |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| innodb_log_buffer_size | 16777216 |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure><p>redo log buffer 刷盘策略</p><ol><li>当事务提交的时候</li><li>当<code>redo log buffer</code>剩余空间小于一半的时候</li><li>后台线程每隔1s刷新一次</li></ol><h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><p>正常情况下，MySQL不发生任何故障，事务对数据库的修改持久化到磁盘上了，那么这一部分的<code>redo log</code>其实就没有保存的必要，留着也是浪费空间，因此<code>redo log</code>采用的是循环写的方式来记录日志。</p><p>默认的，MySQL中<code>redo log</code>日志文件是2个，可以通过如下命令查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_files_in_group%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| innodb_log_files_in_group | 2     |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201018124146.png"></p><p><code>redo log</code>循环写图例如上图所示，其中有两个比较关键的变量</p><ol><li><code>write_pos</code>，表示下一次写<code>redo log</code>的位置</li><li><code>check_point</code>，表示尚未刷新到磁盘的事务修改的起始位置</li></ol><p><code>write_pos ~ check_point</code>就是目前剩余的空间，<code>check_point ~ write_pos</code>就是尚未刷新到磁盘的事务修改。</p><p>之前讲过，如果已经刷新到磁盘的事务修改，那么这一段<code>redo log</code>是没有用的，可以随便覆盖掉，但是那些还没有刷到磁盘的就不能随便乱搞了。那么这样一来就很有可能出现”追尾”的情况：<code>redo log</code>疯狂的写，但是事务修改迟迟没有刷新到磁盘里面。那么此时<code>write_pos</code>就要推着<code>check_point</code>往前走，强制让事务的修改刷新到磁盘里面去，在这个时候，MySQL是不接受任何<code>DML</code>语句的，也就会出现”抖动”。</p><h3 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h3><p>如果每一次事务<code>commit</code>后，都要把期间产生的<code>redo log</code>刷新到磁盘里面，那么这样一来虽然保证了持久性，但与此同时也会严重影响数据库的性能（事务执行时间 = 读取数据页时间 + DML时间 + 刷新<code>redo log</code>到磁盘时间）</p><p>如果对持久性要求不是很高的情况下，可以修改<code>innodb_flush_log_at_trx_commit</code>，该变量有三个可选值：</p><ol><li><code>0</code>: 事务提交以后，不会立刻把日志刷到磁盘里面，而是交给一个后台线程去做。这样一来请求的速度会快很多，但是这样就不能保证持久性了。</li><li><code>1</code>: 事务提交以后立马将日志刷到磁盘</li><li><code>2</code>: 事务提交以后，将<code>redo log</code>提交到<code>操作系统</code>缓冲区，并没有真正刷新到磁盘。这样可以在一定程度上保证持久性，只要操作系统没挂就没事。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><code>redo log</code>是为了保证持久性而生的</li><li><code>redo log</code>默认文件大小是<code>16M</code>（MySQL8.0），默认有两个日志文件</li><li><code>redo log</code>采用循环写的方式记录</li><li>如果发生追尾，那么就会强制刷盘，在此期间MySQL不接受外界的DML请求</li><li>可以通过修改<code>innodb_flush_log_at_trx_commit</code>来调整<code>redo log</code>刷盘机制</li></ol><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>在实际操作过程中，会出现这么一种情况：事务执行错了一条DML，这时候需要回退，之前的那些个DML操作根据原子性的要求，也应该回退，这个时候就需要<code>undo log</code>来救场了。</p><p>上述场景就像下棋一样，往左走了一步，要悔棋就应该向右走一步，回到原来的地方。如果要做一个类似悔棋的功能，那么势必需要保存上一步的位置才能够做到。<code>undo log</code>里面保存的就是修改前的状态。好比说<code>UPDATE</code>之前，值是3，<code>UPDATE</code>之后，值是2，那么MySQL会再执行<code>UPDATE</code>之前记录<code>undo log</code>，记录的值是3，也就是修改前的值。</p><h3 id="undo-log-类型"><a href="#undo-log-类型" class="headerlink" title="undo log 类型"></a>undo log 类型</h3><p><code>undo log</code>日志主要分为两种类型：</p><ol><li><code>INSERT UNDO LOG</code>: 记录<code>INSERT</code>操作的<code>undo log</code></li><li><code>UPDATE UNDO LOG</code>: 记录<code>UPDATE</code>操作的<code>undo log</code>，<code>UPDATE</code>包括了<code>update</code>和<code>delete</code></li></ol><h4 id="INSERT类型的undo-log"><a href="#INSERT类型的undo-log" class="headerlink" title="INSERT类型的undo log"></a>INSERT类型的undo log</h4><p>MySQL中，Insert类型的<code>undo log</code>采用<code>TRX_UNDO_INSERT_REC</code>类型的<code>undo log</code>来存储，每插入一条记录，就会生成一条<code>undo log</code>，而这条记录的<code>roll_pointer</code>隐藏列就会指向这个<code>undo log</code>，当需要回滚的时候，根据<code>undo log</code>就能找到这条插入的记录，然后删除掉就能够恢复到原来的样子了。</p><h4 id="UPDATE类型的undo-log"><a href="#UPDATE类型的undo-log" class="headerlink" title="UPDATE类型的undo log"></a>UPDATE类型的undo log</h4><ol><li>不更新主键的UPDATE<ul><li>原地更新：如果修改后列的值和原来列的值占用的字节数是相等的，那么就会直接在原来的列上进行修改即可。</li><li>删除后重新创建：如果修改列的值和原来的不相等，那么就需要删除（真实的删除）原来的记录，然后插入一条新的记录</li></ul></li><li>更新主键的UPDATE<ul><li>更新主键比较麻烦，因为MySQL的聚簇索引和非聚簇索引底层都是通过主键进行排序的，如果更新了主键，那么索引变动起来非常的麻烦，因此此时首先要对原来的就做<code>delete mark</code>（不是真实的删除，因为此时有可能有其他的事务在访问这条记录），然后再插入一条新的记录。</li></ul></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li><code>undo log</code>的目的是为了实现数据回滚，保证事务的原子性</li><li><code>undo log</code>记录的是修改前的状态，而且是在修改之前进行记录</li></ol><h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p>MySQL中的<code>bin log</code>区别于<code>redo log</code>和<code>undo log</code>，是一种二进制日志，其主要目的是为了：</p><ol><li>复制：搭建主从以后，通过<code>bin log</code>实现主服务器和从服务器之间的数据同步</li><li>数据恢复：数据库被删了，还可以通过<code>bin log</code>来恢复</li><li>增量备份</li></ol><h3 id="bin-log相关操作"><a href="#bin-log相关操作" class="headerlink" title="bin log相关操作"></a>bin log相关操作</h3><ol><li><p>查看<code>bin log</code>的存放目录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------------------+------------------------------------------+</span></span><br><span class="line">| Variable_name                   | Value                                    |</span><br><span class="line">+<span class="comment">---------------------------------+------------------------------------------+</span></span><br><span class="line">| log_bin                         | ON                                       |</span><br><span class="line">| log_bin_basename                | C:\Program Files\MySQL\Data\binlog       |</span><br><span class="line">| log_bin_index                   | C:\Program Files\MySQL\Data\binlog.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                                      |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                                      |</span><br><span class="line">| sql_log_bin                     | ON                                       |</span><br><span class="line">+<span class="comment">---------------------------------+------------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>查看<code>bin log</code>的状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| binlog.000047 |      155 |              |                  |                   |</span><br><span class="line">+<span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>清空<code>bin log</code>文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="error-log"><a href="#error-log" class="headerlink" title="error log"></a>error log</h2><p>MySQL使用过程中，总会遇到一些错误（最常见的就是SQL写错了这种），这些错误会被记录到<code>error log</code>中。</p><p>可以使用<code>--log-error[=file_name]</code>的方式来开启<code>error log</code>，如果<code>file_name</code>缺省，那么默认使用<code>hostname</code></p><p>可以通过<code>show variables like &#39;log_error&#39;;</code>查看<code>error log</code>日志清空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+-------------------------------------------------+</span></span><br><span class="line">| Variable_name | Value                                           |</span><br><span class="line">+<span class="comment">---------------+-------------------------------------------------+</span></span><br><span class="line">| log_error     | C:\Program Files\MySQL\Data\DESKTOP-4QRSVC9.err |</span><br><span class="line">+<span class="comment">---------------+-------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h2 id="slow-query-log"><a href="#slow-query-log" class="headerlink" title="slow query log"></a>slow query log</h2><p>慢查询日志主要是用于记录执行时间超过指定最长时间的SQL语句的一种日志，和该日志相关的配置项是：</p><ol><li><code>slow_query_log</code>: 是否开启慢查询日志</li><li><code>slow_query_log_file</code>: 慢查询日志文件名称</li><li><code>long_query_time</code>: 慢查询时间阈值，超过该值的查询SQL会被记录下来</li><li><code>min_examined_row_limit</code>: 如果查询的记录数少于这个值，即便超时了也不会被记录</li><li><code>log_queries_not_using_indexes</code>: 设置没有使用索引的SQL是否需要被记录</li></ol><h3 id="查看慢查询日志的内容"><a href="#查看慢查询日志的内容" class="headerlink" title="查看慢查询日志的内容"></a>查看慢查询日志的内容</h3><p>打开慢查询日志文件，其中一条记录是这样的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: 2020-10-18T18:55:20.823837Z  </span></span><br><span class="line"><span class="comment"># User@Host: root[root] @ localhost []  Id:     7  </span></span><br><span class="line"><span class="comment"># Query_time: 2.898604  Lock_time: 0.000295 Rows_sent: 2700216  Rows_examined: 300033  </span></span><br><span class="line"><span class="keyword">use</span> emp;  </span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">timestamp</span>=<span class="number">1603018520</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> demo_talbe;</span><br></pre></td></tr></table></figure><h2 id="general-log"><a href="#general-log" class="headerlink" title="general log"></a>general log</h2><p>前面讲到的日志类型如<code>redo log</code>、<code>undo log</code>、<code>bin log</code>、<code>error log</code>和<code>slow query log</code>，涵盖了查询、修改、错误信息、启动信息等所有内容，但是问题在于记录的不是很全面，而<code>slow query log</code>虽然很全面，但也只针对慢查询日志，MySQL中的<code>general log</code>记录了所有的操作日志，不过一般会消耗<code>5% - 10%</code>的性能，一般没事不会去开启。</p><h2 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h2><blockquote><p>The relay log, like the binary log, consists of a set of numbered files containing events that describe database changes, and an index file that contains the names of all used relay log files.</p><p>The term “relay log file” generally denotes an individual numbered file containing database events. The term”relay log” collectively denotes the set of numbered relay log files plus the index file</p></blockquote><p><code>relay log</code>和<code>bin log</code>很类似，都包含了数据库变更的记录，区别在于: <code>bin log</code>是主服务器记录下来的一些数据库变更，而<code>relay log</code>是从服务器从主服务器通过<code>I/O</code>复制过来的一份数据，然后从服务器通过读取<code>relay log</code>来完成和主服务器之间的数据同步。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INSERT INTO SELECT...加锁</title>
      <link href="2020/10/12/2e64bb50.html"/>
      <url>2020/10/12/2e64bb50.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>说出来可能不信，今晚上因为洗数据的问题，经理对我发出灵魂拷问。</p><blockquote><p>为什么要采用<code>rename</code>表的方式来做？你不知道<code>rename</code>是会锁表的吗？这段时间服务不可用怎么办？为什么不用<code>INSERT INTO SELECT...</code>来做？</p></blockquote><p>当时被问得心里比较慌，依稀记得看过一篇文章写到了<code>INSERT INTO SELECT...</code>如果不采用索引也会有锁表的问题，而这个洗数据的过程的WHERE条件里面就没有用到索引，只是当时没有想起来，被问的一愣一愣的，有些语无伦次，太丢脸了😂</p><p>当时考虑的还是比较简单，经理是希望我可以想的更有深度一些，考虑的更全面一点，意识还是要培养起来。</p><h2 id="INSERT-INTO-SELECT…"><a href="#INSERT-INTO-SELECT…" class="headerlink" title="INSERT INTO SELECT…"></a>INSERT INTO SELECT…</h2><p>之前看过的文章是《<a href="https://juejin.im/post/6844904086173646862">Insert into select语句引发的生产事故</a>》，看这篇文章也可以理解<code>INSERT INTO SELECT...</code>加锁的问题。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><blockquote><p>由于代码问题，第三方有一个循环插入数据到表<code>dirty_table</code>里面，导致短时间内这个表就达到了几百万的数据量，关键是还没有建索引，然后查询特别慢，一次耗时5秒左右！于是下定决心要改变这种情况。</p><p>好不容易代码修复完了、有效的数据也迁移到<code>new_table</code>里面去了，接下来就是改改表名就好了，然后就…</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>目前我需要执行的SQL语句是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> dirty_table <span class="keyword">TO</span> dirty_table_old;</span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> new_table <span class="keyword">TO</span> dirty_table;</span><br><span class="line"><span class="comment">-- dirty_table不能直接删了，在new_table里面的数据并不是全部的，dirty_table此时还在不断的接收新的数据进来，需要做增量更新</span></span><br></pre></td></tr></table></figure><p>这种做法毫无疑问在RENAME期间整个和<code>dirty_table</code>相关的业务都要受到影响，经理希望找一种能够不影响业务的方法来做到数据的切换，经理的想法是这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dirty_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> new_table <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dirty_table <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>看上去好像没啥问题，甚至甩我几条街，但是脑子里依稀记得这么搞是有问题的。</p><p>由于WHERE条件里面的列没有加上索引，因此在整个过程中，会对<code>dirty_table</code>加表锁，对<code>new_table</code>逐行加锁，最终的效果和RENAME其实感觉都差不多了…</p><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>结论是有了，但是还需要实际操作来验证。</p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`dirty_table`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`new_table`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">chars = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&#x27;insert_into_select_simulation.sql&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="keyword">file</span>:</span><br><span class="line">    file.write(<span class="string">&#x27;INSERT INTO dirty_table (`c1`, `c2`) VALUES &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&#x27;insert_into_select_simulation.sql&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> <span class="keyword">file</span>:</span><br><span class="line">    <span class="keyword">max</span> = <span class="number">1000000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, <span class="keyword">max</span>):</span><br><span class="line">        file.write(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;, &#x27;&#123;1&#125;&#x27;),&quot;</span>.format(i, chars[i % <span class="keyword">len</span>(chars)]))</span><br><span class="line">    file.write(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;, &#x27;&#123;1&#125;&#x27;);&quot;</span>.format(<span class="keyword">max</span>, chars[<span class="keyword">max</span> % <span class="keyword">len</span>(chars)]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&#x27;insert.sql&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="keyword">file</span>:</span><br><span class="line">    <span class="keyword">start</span> = <span class="number">1000001</span></span><br><span class="line">    <span class="keyword">end</span> = <span class="number">1001001</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">start</span>, <span class="keyword">end</span>):</span><br><span class="line">        file.write(<span class="string">&quot;INSERT INTO dirty_table (`id`, `c1`, `c2`) VALUES (&#x27;&#123;0&#125;&#x27;, &#x27;&#123;1&#125;&#x27;, &#x27;&#123;2&#125;&#x27;);\n&quot;</span>.format(i, i, chars[i % <span class="keyword">len</span>(chars)]))</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据转移脚本</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dirty_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dirty_table <span class="keyword">WHERE</span> c1 &gt; <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 同时执行insert.sql里面的脚本，模拟此时有用户操作的情况</span></span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>先运行<code>INSERT INTO ... SELECT ...</code>语句，然后再运行<code>INSERT INTO ...</code>语句，模拟此时有用户在使用。</p><p>然后你会发现并没有如预期中那样被阻塞😂</p><p>一开始我也很懵逼，甚至有点慌（毕竟我后面还信誓旦旦去找我经理说这玩意也会锁表的😂）</p><p>然后开始翻资料，在<a href="https://www.percona.com/blog/2006/07/12/insert-into-select-performance-with-innodb-tables/">INSERT INTO … SELECT Performance with Innodb tables.</a>这篇文章里介绍了为什么会加锁。这篇文章的大致意思是：一般的<code>SELECT</code>预计是不会加锁的，除非显示的申明<code>IN SHARE MODE</code>或者<code>FOR UPDATE</code>，但是<code>INSERT INTO table1 SELECT * FORM table2</code>是个特例，因为这个时候会锁住表<code>table2</code>，其目的是为了防止在<code>SELECT</code>的时候有其他的事务更新数据导致复制的时候出现不一致的问题。不过这篇资料有点老了，是2008年的，而且写的时候用的好像是MySQL 5.1😂，不过道理还是对的。</p><p>然而还是没有找到为什么这里没有加锁的原因，于是又开始在Google的海洋里遨游，终于给我找到了<code>Stackover Flow</code>里面的一个问题：<a href="https://stackoverflow.com/questions/2640898/how-to-improve-insert-into-select-locking-behavior">How to improve INSERT INTO … SELECT locking behavior</a>，这位大佬的问题大致意思是他们公司有个<code>INSERT INTO ... SELECT ... </code>，然后定时的跑，他发现执行这个东西的时候其它查询涉及到的表的时候耗时很长，问问该怎么提升性能。下面的一个回答给我启发：</p><p>可以设置<code>binlog_format = ROWS</code></p><p>莫非我的这个设置不是ROWS？</p><p>赶紧查查</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%binlog_format%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201013231111.png"></p><p>果然如此，赶紧修改（这里还有查阅binlog_format的资料，但是由于篇幅问题就不展开讨论了，后续会专门对binlog_format进行深入的分析了解）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> binlog_format = <span class="keyword">STATEMENT</span>;</span><br></pre></td></tr></table></figure><p>我以为这样就万事大吉了，然而测试的时候还是没有出现预期中的情况，看来还有一些我没注意到的地方，继续Google😶</p><p>在<a href="https://cloud.tencent.com/developer/article/1639457">insert语句的加锁情况分析</a>中简单介绍了<code>innodb_autoinc_lock_mode</code>的三种模式，原来还需要修改这个东西。和<code>binlog_format</code>不同，这个需要到<code>my.cnf</code>里面修改，然后重新启动MySQL才能生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_autoinc_lock_mode%&#x27;</span></span><br></pre></td></tr></table></figure><p>到此，终于得到我预期的效果了，真的是太难了~</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201013224411.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从验证的过程中来看，MySQL（我的版本是8.0+的）默认的<code>binlog_format</code>、<code>innodb_autoinc_lock_mode</code>设置，可以保证在执行的时候不会锁全表，影响其它业务的正常运行，因此建议还是使用<code>INSERT INTO ... SELECT ... </code>而不是<code>RENAME</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://juejin.im/post/6844904086173646862">Insert into select语句引发的生产事故</a></li><li><a href="https://www.percona.com/blog/2006/07/12/insert-into-select-performance-with-innodb-tables/">INSERT INTO … SELECT Performance with Innodb tables.</a></li><li><a href="https://stackoverflow.com/questions/2640898/how-to-improve-insert-into-select-locking-behavior">How to improve INSERT INTO … SELECT locking behavior</a></li><li><a href="https://cloud.tencent.com/developer/article/1639457">insert语句的加锁情况分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的锁</title>
      <link href="2020/10/08/f312680c.html"/>
      <url>2020/10/08/f312680c.html</url>
      
        <content type="html"><![CDATA[<h2 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁/排他锁"></a>共享锁/排他锁</h2><p>共享锁也称为读锁，一个事务对某一行记录加了共享锁的情况下， 其它的事务也可以对这一行记录加共享锁，但是不可以加排他锁。</p><p>排他锁也称为写锁，一个事务对某一行加了排他锁的情况下，其他的事务不可以对这一行再加读锁或者写锁。</p><p>在查询时加上<code>IN SHARE MODE</code>可以获取共享锁，加上<code>LOCK FOR UPDATE</code>可以获取排他锁，需要注意的是，UPDATE、INSERT等语句会自动加上排他锁。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>在MySQL官网上关于行锁有这么一段话</p><blockquote><p>Record locks always lock index records, even if a table is defined with no indexes. For such cases, <code>InnoDB</code> creates a hidden clustered index and uses this index for record locking</p></blockquote><p>意思是，行锁一定是通过索引加上的，MySQL本身并没有实现行锁的方式，行锁是由存储引擎实现的，因此有的存储引擎支持行锁（例如InnoDB），有的不支持（例如MyISAM），行锁的一个优势是粒度小，并发高，缺点是实现复杂，开销大。</p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>在MySQL中会有这么一种情况，事务A对表T加了行锁，然后事务B对表T加了表锁。此时会出现一个驳论：事务A加了行锁的这一行仅允许事务A进行修改，事务B加了表锁，可以对表中的任意行进行修改。意向锁的目的就是为了让行锁和表锁共存。</p><p>当事务A要给某一行加行锁时，首先会给事务A获取一个该表的意向排他锁，然后才能够获取到这一行的行锁，当B事务要加表锁的时候，由于此时表上已经有了意向排他锁了，因此事务B加锁失败，被阻塞了。其整个过程是这样的：</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>SELECT … FOR UPDATE;<br />获取到意向排他锁（IX）、获取到排他锁（X）</td><td></td></tr><tr><td></td><td>LOCK TABLES ….;<br />阻塞，等待锁释放</td></tr><tr><td>commit;</td><td></td></tr><tr><td></td><td>获取表锁成功</td></tr></tbody></table><p>意向锁和其他锁的兼容情况：</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><div class="note info simple"><p>需要注意的是，意向锁一定是表级锁</p></div><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>MySQL对间隙锁的定义是这样的：</p><blockquote><p>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record. For example, <code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> prevents other transactions from inserting a value of <code>15</code> into column <code>t.c1</code>, whether or not there was already any such value in the column, because the gaps between all existing values in the range are locked.</p></blockquote><p>这段话说明：</p><ol><li>间隙锁一定是一个开区间</li><li>间隙锁会防止其它事务插入间隙区间内的值</li></ol><p>另一段说明是这样的：</p><blockquote><p>Gap locks in <code>InnoDB</code> are “purely inhibitive”, which means that their only purpose is to prevent other transactions from inserting to the gap. Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.</p></blockquote><p>这段话的意思是，不同的事务同一个间隙锁并不会冲突，甚至有包含关系也没事。</p><p>还有一段说明是这样的：</p><blockquote><p>There are also other effects of using the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a> isolation level. Record locks for nonmatching rows are released after MySQL has evaluated the <code>WHERE</code> condition. For <code>UPDATE</code> statements, <code>InnoDB</code> does a “semi-consistent” read, such that it returns the latest committed version to MySQL so that MySQL can determine whether the row matches the <code>WHERE</code> condition of the <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a>.</p></blockquote><p>这段话的意思是，在低于或等于读已提交的隔离级别下，间隙锁是无效的，因为这种隔离级别总会读取到最新的数据。</p><p>综上所述：</p><ol><li>间隙锁锁定的是一个开区间</li><li>其他事务不可以向间隙锁区间内插入值</li><li>多个事务可以获取同一个间隙锁</li><li>间隙锁只在可重复读的情况下生效（串行化没有必要了）</li></ol><h3 id="间隙锁测试"><a href="#间隙锁测试" class="headerlink" title="间隙锁测试"></a>间隙锁测试</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_lock_test`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sql&gt; SELECT * FROM t_lock_test;</span><br><span class="line">+<span class="comment">---+---+</span></span><br><span class="line">| a | b |</span><br><span class="line">+<span class="comment">---+---+</span></span><br><span class="line">| 0 | a |</span><br><span class="line">| 3 | c |</span><br><span class="line">| 5 | d |</span><br><span class="line">| 6 | g |</span><br><span class="line">+<span class="comment">---+---+</span></span><br></pre></td></tr></table></figure><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><h4 id="按照主键索引加间隙锁"><a href="#按照主键索引加间隙锁" class="headerlink" title="按照主键索引加间隙锁"></a>按照主键索引加间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> a = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h4 id="按照主键索引范围加间隙锁"><a href="#按照主键索引范围加间隙锁" class="headerlink" title="按照主键索引范围加间隙锁"></a>按照主键索引范围加间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;h&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h4 id="锁住不存在的数据"><a href="#锁住不存在的数据" class="headerlink" title="锁住不存在的数据"></a>锁住不存在的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> a = <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;m&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;h&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h4 id="按照非主键索引加间隙锁"><a href="#按照非主键索引加间隙锁" class="headerlink" title="按照非主键索引加间隙锁"></a>按照非主键索引加间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> b = <span class="string">&#x27;c&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">-- 失败</span></span><br></pre></td></tr></table></figure><h3 id="判断间隙锁的范围"><a href="#判断间隙锁的范围" class="headerlink" title="判断间隙锁的范围"></a>判断间隙锁的范围</h3><p>从上述例子中，不难看出间隙锁的范围，以按照为主键索引加间隙锁为例</p><p>其范围区间可以划分为</p><p><code>(-∞, a) -- (a, c) -- (c, d)</code></p><p>由于非聚簇索引的特性，如果非聚簇索引相同的话，就会按照主键索引进行排序，因此实际上根据索引结构来划分的话，其锁定的区间应该是这样的</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201011214945.png"></p><p>在这个范围内插入值都会被锁定</p><h3 id="间隙锁总结"><a href="#间隙锁总结" class="headerlink" title="间隙锁总结"></a>间隙锁总结</h3><p>从上述的几个例子中不难看出间隙锁的几个特性：</p><ol><li>按照主键索引不不会加间隙锁</li><li>按照主键索引范围或者锁住不存在的值的时候才会加间隙锁</li><li>按照非主键索引一定会加间隙锁</li><li>还有一点没有在测试中展现，主键索引和唯一索引的效果是一样的</li></ol><h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><p>MySQL对临键锁的定义是这样的</p><blockquote><p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p></blockquote><p>大致的意思就是，临键锁是行锁和间隙锁的一种组合，临键锁不仅要锁住索引行，还要锁住范围区间，可以看作是一个特殊的间隙锁</p><p>MySQL对临键锁还有一个比较重要的描述</p><blockquote><p>By default, <code>InnoDB</code> operates in <code>REPEATABLE READ</code> transaction isolation level. In this case, <code>InnoDB</code> uses next-key locks for searches and index scans, which prevents phantom rows </p></blockquote><p>InnoDB在可重复读这种隔离级别下，是通过临键锁来进行搜索和索引扫描的，这样的一个好处是可以在一定程度上防止幻读的出现。防止幻读的原理很简单，因为锁的是一个区间，如果要在这个区间里面插入值，那么是会阻塞的，而之所以说是在一定程度上，那是因为首先需要加锁，如果采用的是普通的<code>SELECT</code>而不是<code>SELECT ... IN SHARE MODE</code>或者<code>SELECT ... FOR UPDATE</code>，那么MySQL采用的还是快照读，并不会加锁。</p><h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><p>MySQL对插入意向锁的描述是这样的：</p><blockquote><p>An insert intention lock is a type of gap lock set by <a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a> operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</p></blockquote><p>这段话的大意是这样的：插入意向锁是一种<code>间隙锁</code>，插入意向锁的目的是在多个事务并发插入的时候，有可能这些事务插入的不是同一个地方，为了避免互相等待而弄出来的东西。</p><p>总结归纳一下插入意向锁：</p><ol><li>是一个间隙锁</li><li>和间隙锁不同的地方是，插入意向锁锁定的区间是一条记录，而不是一个范围</li><li>插入意向锁的目的是为了提升并发插入的效率</li></ol><h2 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h2><p>还是先来一段MySQL官方的描述</p><blockquote><p>An <code>AUTO-INC</code> lock is a special table-level lock taken by transactions inserting into tables with <code>AUTO_INCREMENT</code> columns. In the simplest case, if one transaction is inserting values into the table, any other transactions must wait to do their own inserts into that table, so that rows inserted by the first transaction receive consecutive primary key values.</p></blockquote><p>MySQL数据库里面字段实可以设置自增的，这些自增的字段在并发的情况下保证不会出现数据安全问题，全靠自增锁维持，在往自增字段里面插入值的时候，会加一个自增锁，这个锁是<span style="color:red;">表锁</span>，所以其它的事务在插入的时候，只能等待前面那个获取到自增锁的事务弄好了才能往里面插入。这就是为什么使用MySQL的主键自增策略会有瓶颈问题的原因所在。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL官网</a></li><li><a href="https://blog.csdn.net/Saintyyu/article/details/91269087">MySQL常见的七种锁详细介绍</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL JOIN执行细节</title>
      <link href="2020/10/08/1ceae895.html"/>
      <url>2020/10/08/1ceae895.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然间看到这一篇博客《<a href="https://segmentfault.com/a/1190000015572505">Mysql - JOIN详解</a>》，其中有一部分是对联表过程的描述，这段描述看完以后感觉怪怪的，如下:</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://i.loli.net/2020/10/08/ucHMS5lYomRaDbi.png" alt="3__8CHW8T~ZITUX9MYVE_@T.png"></p><p>如果两个表的数据量都在百万级别，那么照这个说法，先来一次笛卡尔积，得到的<code>vt1</code>表将是十万亿+级别的，这直接就可以把内存搞炸了吧……</p><p>之后看了其它的博客和官方文档以后，JOIN是通过两种算法<code>Nested-Loop Join</code>和<code>Block Nested-Loop Join</code>实现的</p><h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested-Loop Join"></a>Nested-Loop Join</h2><p>当ON条件使用索引时，采用的是<code>Nested-Loop Join</code>算法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_student.*, t_score.* <span class="keyword">FROM</span> t_student <span class="keyword">JOIN</span> t_score <span class="keyword">ON</span> t_student.stu_id = t_score.stu_id <span class="keyword">WHERE</span> t_student.stu_id = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>假设在<code>stu_id</code>上加了索引，那么这个JOIN的过程是这样的（假设以<code>t_student</code>做驱动表）：</p><ol><li><p>根据条件<code>t_student.stu_id = &#39;1&#39;</code>从<code>t_student</code>中获取对应的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_student</code>的数据</p></li><li><p>根据这一行数据的<code>stu_id</code>与<code>t_score</code>关联，获取<code>t_score</code>的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_score</code>的数据</p></li><li><p>将两行数据组成一条完整的结果，存入<code>NET BUFFER</code>中</p></li><li><p>重复上述过程，直到<code>t_student</code>没有满足条件的行为止</p></li></ol><p>从上述的描述中可以看出，要查询出数据每次都要进行回表操作，而回表操作是随机IO，性能上面肯定不行。MySQL对这一步做了一些优化，操作系统读取数据的时候，不是指定了<code>id=xxx</code>就只会给你读这一条数据出来，而是一次加载一页的数据，也就是这条数据周边的其它数据也一起加载进来了。基于此，在第2步和第4步的时候，不会立刻去回表查询，而是先存入<code>read_md_buffer</code>，按照主键排序以后，再去回表查询，这样有可能下一条需要查询的数据在上一次查询的时候已经加载进内存了，节省了IO的次数。</p><h2 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h2><p>如果没有使用索引的话，那么就在只能做全表扫描了，还是原来的SQL，仍然假设<code>t_student</code>做驱动表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_student.*, t_score.* <span class="keyword">FROM</span> t_student <span class="keyword">JOIN</span> t_score <span class="keyword">ON</span> t_student.stu_id = t_score.stu_id <span class="keyword">WHERE</span> t_student.stu_id = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><ol><li><p>根据条件<code>t_student.stu_id = &#39;1&#39;</code>从<code>t_student</code>中获取对应的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_student</code>的数据，放入<code>JOIN BUFFER</code></p></li><li><p>再根据<code>JOIN BUFFER</code>中的数据，根据ON条件对<code>t_score</code>做全表扫描，找出符合条件的值</p></li><li><p>如果<code>t_student</code>表的数据没有扫描完，清空<code>JOIN BUFFER</code>，继续扫描<code>t_student</code>，重复</p></li></ol><h2 id="驱动表为什么一定是小表"><a href="#驱动表为什么一定是小表" class="headerlink" title="驱动表为什么一定是小表"></a>驱动表为什么一定是小表</h2><div class="note info simple"><p>暂且忽略可能的回表操作</p></div><p>MySQL JOIN的情况分为使用了索引和未使用索引这两种情况，假设驱动表行数为N，被驱动表行数为M</p><ol><li>使用索引的情况<ul><li>首先对驱动表根据条件做一次全表扫描，扫描行数为N</li><li>接着根据索引查询被驱动表，扫描行数为$N * \log_2M$</li><li>总的次数为$N + N * \log_2M$</li></ul></li><li>不适用索引的情况<ul><li>假设驱动表分段放入JOIN BUFFER需要分成K段，$K = \lambda * N$</li><li>总的扫描次数是$N + \lambda * N * M$</li></ul></li></ol><p>从上述两种情况来看，N或者M越小，扫描次数就越少，效率也就越高。减小N对于减小次数的幅度会比减小M的更大一些，因此驱动表选择小表更合适</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000015572505">Mysql - JOIN详解</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html">MySQL官网</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题</title>
      <link href="2020/10/08/af355a99.html"/>
      <url>2020/10/08/af355a99.html</url>
      
        <content type="html"><![CDATA[<h2 id="0001-两数之和"><a href="#0001-两数之和" class="headerlink" title="0001 两数之和"></a>0001 两数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><div class="tabs" id="0001"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0001-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0001-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0001-1"><p>最简单的方法就是两层循环遍历，直到找到符合条件的组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">int</span> n2 = target - n1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == n2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0001-2"><p>第一种做法显然会比较耗时一点，其耗时主要体现在需要重复的去寻找匹配的值，这个值可能是不存在的，那么这里就要做一次无用功。为了节省这一部分时间，可以将值全部通过hash散列存储起来，之后查找的时候就可以在O(1)时间复杂度内找到对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">int</span> n2 = target - n1;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(n2)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0002-两数相加"><a href="#0002-两数相加" class="headerlink" title="0002 两数相加"></a>0002 两数相加</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001141.svg" /></div><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><div class="tabs" id="0002"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0002-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0002-1"><p>很简单的一个链表相加的算式，唯一需要注意的地方是最后的结果可能有进位需要单独处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p1 = l1, p2 = l2, curr = res;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> || p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = p1 == <span class="keyword">null</span> ? <span class="number">0</span> : p1.val;</span><br><span class="line">        <span class="keyword">int</span> val2 = p2 == <span class="keyword">null</span> ? <span class="number">0</span> : p2.val;</span><br><span class="line">        p1 = p1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : p1.next;</span><br><span class="line">        p2 = p2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : p2.next;</span><br><span class="line">        <span class="keyword">int</span> sum = flag + val1 + val2;</span><br><span class="line">        flag = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0004-寻找两个正序数组的中位数"><a href="#0004-寻找两个正序数组的中位数" class="headerlink" title="0004 寻找两个正序数组的中位数"></a>0004 寻找两个正序数组的中位数</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><p>示例 1：</p><blockquote><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000</p></blockquote><p>示例 4：</p><blockquote><p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000</p></blockquote><p>示例 5：</p><blockquote><p>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p></blockquote><div class="note info simple"><p>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p></div><div class="tabs" id="0004"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0004-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0004-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0004-1"><p>最简单的就是合并两个数组了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = merge(nums1, nums2);</span><br><span class="line">    <span class="keyword">if</span> (nums.length % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>] / <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (nums[nums.length / <span class="number">2</span>] + nums[nums.length / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] mergeArr = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + nums2.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            mergeArr[index++] = nums1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeArr[index++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length) &#123;</span><br><span class="line">        mergeArr[index++] = nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums2.length) &#123;</span><br><span class="line">        mergeArr[index++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0004-2"><p>其实并不需要合并两个数组，他们本身是有序的，如果总的长度是奇数，那么只要找到中间那个就好，否则找到中间那两个。实际上就是比较小的数丢掉<code>len / 2</code>个，然后取<code>len / 2 + 1</code>或者后面两个数的平均数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length, len2 = nums2.length, len = len1 + len2;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt;= len / <span class="number">2</span>; index++) &#123;</span><br><span class="line">        left = right;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1 &amp;&amp; (j &gt;= len2 || nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">            right = nums1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0011-盛最多水的容器"><a href="#0011-盛最多水的容器" class="headerlink" title="0011 盛最多水的容器"></a>0011 盛最多水的容器</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p> <img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例：</p><blockquote><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p></blockquote><div class="tabs" id="0004"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0004-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0004-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0004-1"><p>很简单的思路，两个左右指针不断地向中间靠拢，此时他们的距离一定会缩短，为了保证容量有可能是在增大的，因此他们两个指针的最小的那个向前移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">        res = Math.max(res, temp);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0004-2"><p>解法2是对解法1的一次优化，解法1有一些不必要的尝试，例如如果小的那个指针向前移动以后，高度比原来的还小，那么这个是没有必要去计算的，因为宽度已经变小了，高度再变小只会比原来的更小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> minWidth = Math.min(height[left], height[right]);</span><br><span class="line">        <span class="keyword">int</span> temp = minWidth * (right - left);</span><br><span class="line">        res = Math.max(res, temp);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; height[left] &lt;= minWidth) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; height[right] &lt;= minWidth) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0015-三数之和"><a href="#0015-三数之和" class="headerlink" title="0015 三数之和"></a>0015 三数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><blockquote><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><div class="tabs" id="0015"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0015-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0015-2"><i class="fas fa-pen"></i>解法2</button></li><li class="tab"><button type="button" data-href="#0015-3"><i class="fas fa-pen"></i>解法3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0015-1"><p>最最简单的一个方法就是，直接三层循环去搜索就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = j + <span class="number">1</span>; h &lt; nums.length; h++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (h &gt; j + <span class="number">1</span> &amp;&amp; nums[h - <span class="number">1</span>] == nums[h]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[h] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[h]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0015-2"><p>其实也比较简单，比较关键的一步是要先对这个数组排序，然后还要注意的就是不要有重复的组合出现，做到不重复也简单，只要新的组合开头不是之前出现过的那个元素就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    findThreeNumsSum(nums, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findThreeNumsSum</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp, <span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.size() == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index) &#123;</span><br><span class="line">            <span class="comment">// 避免重复</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        findThreeNumsSum(nums, res, temp, i + <span class="number">1</span>, target + nums[i]);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0015-3"><p>前面两种方式都是不能通过的，超出了时间限制。其实前面两种方式的核心思想都是一个一个的去尝试，但是这是完全没有必要的，前面两种方式都有一个共同的地方：对数组进行了排序，这个很重要，说明数组是有序的，这样的话其实可以将问题简化为 ：确定了某一个数，求另外两个数的和为某一个数的组合，这不就又回到了两数之和的场景了吗？之前的两数之和因为是无序的，所以用了额外的存储空间记录位置信息，而此时是有序的，那么就完全可以使用双指针的方式找到指定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++l]) &#123;&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r]) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0016-最接近的三数之和"><a href="#0016-最接近的三数之和" class="headerlink" title="0016 最接近的三数之和"></a>0016 最接近的三数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><div class="tabs" id="0016"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0016-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0016-1"><p>和题目 <a href="#0015">0015</a> 一样，思路都是一样的，只不过换了一个模式而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> minDis = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> dis = sum - target;</span><br><span class="line">            <span class="keyword">if</span> (dis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left - <span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right + <span class="number">1</span>] == nums[right]) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(dis) &lt; minDis) &#123;</span><br><span class="line">                minDis = Math.abs(dis);</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0018-四数之和"><a href="#0018-四数之和" class="headerlink" title="0018 四数之和"></a>0018 四数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p><strong>答案中不可以包含重复的四元组。</strong></p><p>示例：</p><blockquote><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p></blockquote><div class="tabs" id="0018"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0018-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0018-2"><i class="fas fa-pen"></i>解法2</button></li><li class="tab"><button type="button" data-href="#0018-3"><i class="fas fa-pen"></i>解法3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0018-1"><p>前面经历了两数之和、三数之和、最接近的三数之和之后，到了现在一些基本的套路总是要会了😂</p><p>还是参考三数之和的做法，双层循环直接怼上去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[--right] == nums[right + <span class="number">1</span>]) &#123;&#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[++left] == nums[left - <span class="number">1</span>]) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0018-2"><p>当然也可以使用DFS的方式来解决这道题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    findRes(nums, target, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findRes</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.size() == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        findRes(nums, target - nums[i], i + <span class="number">1</span>, res, temp);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无情超时😂</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0018-3"><p>看看别人的做法，我丢，原来还可以这样剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min1 = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (min1 &gt; target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max1 = nums[i] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (max1 &lt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min2 = nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (min2 &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> max2 = nums[i] + nums[j] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (max2 &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[--right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[++left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0026-删除排序数组中的重复项"><a href="#0026-删除排序数组中的重复项" class="headerlink" title="0026 删除排序数组中的重复项"></a>0026 删除排序数组中的重复项</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><blockquote><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><div class="tabs" id="0026"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0026-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0026-1"><p>题目很简单，一个很容易想到的方法就是，弄一个额外的数组出来，然后把全部的不重复的值放到这个额外的数组里面去，然后覆盖掉原来的数组即可，这种方法太简单了。</p><p>另一个方法就是直接在原有的基础上进行修改，两个指针<code>p1</code>、<code>p2</code>，<code>p1</code>代表新数组下一个不重复的元素的下标，<code>p2</code>代表就数组下一个不重复元素的下标，这么说意思就很明确了，就是用<code>p2</code>去找下一个不重复的元素，然后覆盖掉<code>p1</code>的位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums == <span class="keyword">null</span> ? <span class="number">0</span> : nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">1</span>, p2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; nums.length &amp;&amp; nums[p2] == nums[p2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2 &lt; nums.length &amp;&amp; nums[p2] != nums[p2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[p1++] = nums[p2++];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0027-移除元素"><a href="#0027-移除元素" class="headerlink" title="0027 移除元素"></a>0027 移除元素</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><blockquote><p>给定 nums = [3,2,2,3], val = 3,</p><p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>注意这五个元素可为任意顺序。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><div class="tabs" id="0026"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0026-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0026-1"><p>题目挺简单的，就不多解释了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; nums.length &amp;&amp; nums[p2] == val) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2 &lt; nums.length) &#123;</span><br><span class="line">            nums[p1++] = nums[p2++];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0031-下一个排列"><a href="#0031-下一个排列" class="headerlink" title="0031 下一个排列"></a>0031 下一个排列</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3 → 1,3,2</code><br><code>3,2,1 → 1,2,3</code><br><code>1,1,5 → 1,5,1</code></p><div class="tabs" id="0031"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0031-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0031-1"><p>主要的思路是这样的: </p><ol><li>首先这个要求是下一个排列是升序的，那么将两个数中前面的大数和前面的小数对调一下就好了，比如<code>1234</code>，将4和3对调一下就是<code>1243</code>，满足升序的排列就出来了</li><li>当然这边的下一个排列肯定说的是最小的那一个，那么这个时候对调的规则还是一样的<ol><li>首先找到第一个前面的数小于后面的数的数，记这个位置为<code>i</code>，此时<code>i</code>之后的数列是一个降序数列</li><li>然后从后往前找到第一个小于位置<code>i</code>的数，及这个位置为<code>j</code>，将这两个数对调位置</li><li>最后将<code>i ~ len</code>这一段数列进行反转即可</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt;= nums[i]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        swap(nums, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0033-搜索旋转排序数组"><a href="#0033-搜索旋转排序数组" class="headerlink" title="0033 搜索旋转排序数组"></a>0033 搜索旋转排序数组</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你一个升序排列的整数数组 nums ，和一个整数 target 。</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。</p><p>请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>示例 1：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1], target = 0<br>输出：-1</p></blockquote><div class="tabs" id="0033"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0033-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0033-1"><p>简单的暴力求解就不多说了，为了更加快一点，主要是运用到二分搜索的思想。</p><p>细心研究题目就会发现，找到数组的中点，不是左边有序就是右边有序。那么就可以将<code>target</code>和有序的那一边进行比较，如果在有序的里面，那么就搜索这个有序的，否则搜索无序的，如此一来，每次都会丢弃一半的数据，大大提高了查询的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 左边有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右边有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0034-在排序数组中查找元素第一个和最后一个出现的位置"><a href="#0034-在排序数组中查找元素第一个和最后一个出现的位置" class="headerlink" title="0034 在排序数组中查找元素第一个和最后一个出现的位置"></a>0034 在排序数组中查找元素第一个和最后一个出现的位置</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p></blockquote><div class="tabs" id="0034"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0034-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0034-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0034-1"><p>既然是排序的数组，那么就可以直接上二分搜索。根据二分搜索查找出来的一个位置，然后左右两边搜索找到第一个和最后一个位置就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = binarySearch(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = index, right = index;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length &amp;&amp; nums[right] == target) &#123;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[mid] &gt; target ? binarySearch(nums, target, left, mid - <span class="number">1</span>)</span><br><span class="line">                : binarySearch(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0034-2"><p>第一种解法很简单也很容易理解，事实上我们更希望的是可以直接 找到第一个和最后一个位置，而不是后面再去搜搜一次。</p><p><strong>找到第一个位置</strong></p><ol><li>如果找到的中点<code>nums[mid] == target</code>，那么这个<code>mid</code>可能是第一个位置也可能不是第一个位置，因此此时不是原来的二分搜索那样直接返回而是继续往左边找，即<code>right = mid - 1</code></li><li>如果此时<code>nums[mid] &gt; target</code>，那么就需要到<code>mid</code>的左边找，即<code>right = mid - 1</code></li><li>如果此时<code>nums[mid] &lt; target</code>，那么就需要到<code>mid</code>的右边找，即<code>left = mid + 1</code></li></ol><p><strong>找到最后一个位置</strong></p><p>和找到第一个位置唯一不同的地方在于第一步，如果此时找到的<code>mid</code>满足<code>nums[mid] == target</code>，那么这个位置可能是最后一个也可能不是，就需要到右边继续找，即<code>left = mid + 1</code>，之后的两步相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = findFirstPosition(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = findLastPosition(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirstPosition(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirstPosition(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirstPosition(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; left &lt; nums.length &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findLastPosition(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findLastPosition(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findLastPosition(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; right &lt; nums.length &amp;&amp; nums[right] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0035-搜索插入位置"><a href="#0035-搜索插入位置" class="headerlink" title="0035 搜索插入位置"></a>0035 搜索插入位置</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><blockquote><p>输入: [1,3,5,6], 5<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: [1,3,5,6], 2<br>输出: 1</p></blockquote><p>示例 3:</p><blockquote><p>输入: [1,3,5,6], 7<br>输出: 4</p></blockquote><p>示例 4:</p><blockquote><p>输入: [1,3,5,6], 0<br>输出: 0</p></blockquote><div class="tabs" id="0035"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0035-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0035-1"><p>题目很简单，暴力循环就可以解决，但是当然不能用这么<code>low</code>的方法。既然数组是有序的，那么就可以怼二分搜索，这边通过二分搜索找到一个尽可能接近<code>target</code>的数就可以了。</p><ol><li>如果找到的<code>nums[mid] == target</code>，这个位置就是要插入的位置（不可能有重复的数据）</li><li>如果<code>nums[mid] &gt; target</code>，说明需要到左边去查找符合的数</li><li>如果<code>nums[mid] &lt; target</code>，那么就去右边找</li><li>最后非常重要的一点，<code>left &lt; right</code>而不是<code>lft &lt;= right</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] &gt;= target ? left : left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0039-组合总数"><a href="#0039-组合总数" class="headerlink" title="0039 组合总数"></a>0039 组合总数</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li><p>所有数字（包括 target）都是正整数。</p></li><li><p>解集不能包含重复的组合。 </p></li></ul><p>示例 1：</p><blockquote><p>输入：candidates = [2,3,6,7], target = 7,<br>所求解集为：<br>[<br>  [7],<br>  [2,2,3]<br>]</p></blockquote><p>示例 2：</p><blockquote><p>输入：candidates = [2,3,5], target = 8,<br>所求解集为：<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p></blockquote><div class="note info simple"><p>提示：</p><p>1 &lt;= candidates.length &lt;= 30<br>1 &lt;= candidates[i] &lt;= 200<br>candidate 中的每个元素都是独一无二的。<br>1 &lt;= target &lt;= 500</p></div><div class="tabs" id="0035"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0035-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0035-1"><p>题目很简单，直接用DFS就可以完美搞定。只需要认为是在不断的拼凑一个<code>targer</code>，不断地尝试就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    <span class="keyword">if</span> (candidates[<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        dfs(nums, target - nums[i], i, res, temp);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0040-组合总数II"><a href="#0040-组合总数II" class="headerlink" title="0040 组合总数II"></a>0040 组合总数II</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li><p>所有数字（包括目标数）都是正整数。</p></li><li><p>解集不能包含重复的组合。 </p></li></ul><p>示例 1:</p><blockquote><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p></blockquote><p>示例 2:</p><blockquote><p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p></blockquote><div class="tabs" id="0040"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0040-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0040-1"><p>和组合总数的思路是一样的，唯一的区别就是一个数只能用一次了，但是这个其实并不影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        dfs(nums, target - nums[i], i + <span class="number">1</span>, res, temp);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0041-缺失的第一个正数"><a href="#0041-缺失的第一个正数" class="headerlink" title="0041 缺失的第一个正数"></a>0041 缺失的第一个正数</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><p>示例 1:</p><blockquote><p>输入: [1,2,0]<br>输出: 3</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,4,-1,1]<br>输出: 2</p></blockquote><p>示例 3:</p><blockquote><p>输入: [7,8,9,11,12]<br>输出: 1</p></blockquote><div class="note info simple"><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p></div><div class="tabs" id="0041"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0041-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0041-1"><p>由于只能用到常数级别的空间复杂度，那么就只好复用原来的数组了，假如说在<code>i</code>位置的数为<code>nums[i]</code>，那么将对应位置的数变成负数，即<code>nums[nums[i] - 1] = -nums[nums[i - 1]]</code>，这就代表着，数字<code>nums[i]</code>出现过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = nums.length + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= nums.length) &#123;</span><br><span class="line">            nums[temp - <span class="number">1</span>] = -Math.abs(nums[temp - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0042-接雨水"><a href="#0042-接雨水" class="headerlink" title="0042 接雨水"></a>0042 接雨水</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"></p><blockquote><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p></blockquote><div class="tabs" id="0042"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0042-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0042-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0042-1"><p>这个题目其实也不难，对于某一列<code>i</code>，如果这个列能够积攒到雨水，那么必定存在左右两边的最高点都比<code>i</code>列大，所以这道题就变成了找到第<code>i</code>列和左右两边最高点的差，然后求和的题目了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>, min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            maxLeft = Math.max(maxLeft, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            maxRight = Math.max(maxRight, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        min = Math.min(maxLeft, maxRight);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; min) &#123;</span><br><span class="line">            res += min - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0042-2"><p>这个解法只是对解法1的优化，事实上可以不需要每次都去查找左右两边的最大值，完全可以保存下来的，这样就节省了很多的时间。</p><p>对于一个已知的列<code>i</code>而言，它的作边最大值要么就是他左边的那个值，要么就是上一个左边的最大值。</p><p>同理，对于已知列<code>i</code>而言，其右边的最大值要么是它右边的数，要么是上一个右边的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] maxLeft = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">int</span>[] maxRight = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        maxLeft[i] = Math.max(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxRight[i] = Math.max(maxRight[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(maxLeft[i], maxRight[i]);</span><br><span class="line">        <span class="keyword">if</span> (min &gt; height[i]) &#123;</span><br><span class="line">            res += min - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0045-跳跃游戏"><a href="#0045-跳跃游戏" class="headerlink" title="0045 跳跃游戏"></a>0045 跳跃游戏</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p><strong>示例：</strong></p><blockquote><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p></blockquote><p><strong>说明：</strong></p><p>假设你总是可以到达数组的最后一个位置。</p><div class="tabs" id="0045"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0045-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0045-2"><i class="fas fa-pen"></i>解法2</button></li><li class="tab"><button type="button" data-href="#0045-3"><i class="fas fa-pen"></i>解法3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0045-1"><p>第一个想法是：从最后一个元素开始，因为要走到最后一个位置嘛，那我就一个一个试呗，先看看前面一个能不能走到我这里来，再看看我前面的前面能不能走到我这里来…依次循环查找，最终超时了😂，不管怎么样也算是一个思路了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> minStep = dfs(nums, i, nums.length - i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        res = Math.min(res, minStep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> curr, <span class="keyword">int</span> minLen, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[curr] &gt;= minLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= curr; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minStep = dfs(nums, curr - i, i, step + <span class="number">1</span>);</span><br><span class="line">            res = Math.min(res, minStep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0045-2"><p>听说这种方法叫贪心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>, position = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                step++;</span><br><span class="line">                position = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0045-3"><p>实在不会，看看答案区的大神都是这么做的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPosition = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxPosition = Math.max(maxPosition, i + nums[i]); </span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPosition;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0048-旋转数组"><a href="#0048-旋转数组" class="headerlink" title="0048 旋转数组"></a>0048 旋转数组</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><blockquote><p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p></blockquote><div class="tabs" id="0045"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0045-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0045-1"><p>很简单，先求这个数组的转置，然后再把每行进行逆序就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">        reverse(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        swap(nums, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法实现</title>
      <link href="2020/10/08/9f76ab7a.html"/>
      <url>2020/10/08/9f76ab7a.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>雪花算法生成的id总共由64位组成，其每个部分如图所示：</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://i.loli.net/2020/09/17/9Iaefb4S8EwNL3F.png" alt="13382703-b64e38457ddd13e2.png"></p><p><code>1bit</code>: 二进制中最高位是符号位，用于确定数值的正负，0代表正数，1代表负数。一般而言<code>id</code>都是正数，所以最高位这边的<code>0</code>一般是不会动的。</p><p><code>41bit</code>: 接下来的<code>41bit</code>用于记录时间戳（毫秒级），41位可以表示$2^{41} - 1$个数字，换算成年就是$(2^{41} - 1) / (1000 * 60 * 60 * 60 * 24 * 365) = 69$年</p><p><code>10bit</code>: 接下来的<code>10bit</code>用于区分不同的机器，因为系统可能不止一台机器，每一台机器生成<code>id</code>的时间戳有可能相同，因此需要标记不同的机器。<code>10bit</code>分<code>5bit</code>的<code>centerId</code>和<code>5bit</code>的<code>workerId</code>。</p><p><code>12bit</code>: 序列号是用来记录同一毫秒内产生的不同的id。一台机器有可能在同一毫秒内会产生多个id。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳 2020-01-01 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimeStamp = <span class="number">1577808000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id占据的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据表时id所占位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大支持的workerId 31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大支持的dataCenterId 31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDataCenterId = ~(-<span class="number">1L</span> &lt;&lt; dataCenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号所占位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识起始位置（从右往左数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳标识起始位置（从右往左数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStampShift = sequenceBits + workerIdBits + dataCenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号掩码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一次生成的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> dataCenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;WorkerId Can Not Greater Than %s Or Less Than 0&quot;</span>, workerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;DataCenterId Can Not Greater Than %s Or Less Than 0&quot;</span>, dataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个id 线程安全的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取的时间戳有精度缺失的问题</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = SystemClock.now();</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">// 有可能出现了系统时钟回退</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock Move Backwards, Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">// 同一毫秒，毫秒内序列化id</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 序列化耗尽，阻塞直到获取到下一个时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimeStamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新的毫秒值 重置序列号</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimeStamp = timestamp;</span><br><span class="line">        <span class="keyword">return</span> ((lastTimeStamp - startTimeStamp) &lt;&lt; timeStampShift)</span><br><span class="line">                | (dataCenterId &lt;&lt; dataCenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdBits)</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一毫秒，获取新的毫秒值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimeStamp 最后一次获取到毫秒值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个毫秒值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimeStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = -<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            timestamp = SystemClock.now();</span><br><span class="line">        &#125; <span class="keyword">while</span> (timestamp &lt;= lastTimeStamp);</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System.currentTimeMillis优化</title>
      <link href="2020/10/08/84d1ebba.html"/>
      <url>2020/10/08/84d1ebba.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前开发的时候经常使用<code>System.currentTimeMillis</code>来获取当前的时间戳，刚好解决雪花算法生成重复ID的时候看到了这个的优化，好奇之下对这个优化及进行了探索。</p><h2 id="System-currentTimeMillis为什么慢"><a href="#System-currentTimeMillis为什么慢" class="headerlink" title="System.currentTimeMillis为什么慢"></a>System.currentTimeMillis为什么慢</h2><p>为什么<code>System.currentTimeMillis</code>会耗时呢？有一篇<a href="https://pzemtsov.github.io/2017/07/23/the-slow-currenttimemillis.html">文章</a>对这个做了解释。简而言之就是：调用底层的获取时间戳的方法需要<strong>从用户态切换到内核态</strong>，而且这个获取时间戳的方法还受到Linux计时器的影响（Linux系统中只有一个计时器）如果并发访问的情况下，会出现资源争抢激烈的情况。</p><p>Linux计时器分为两种：HPET和TSC，HPET性能较差，因为HPET通过串行来处理并发请求，TSC性能稍好一点，会有专门的寄存器记录时间，缺点是稳定性不好，因为TSC是存硬件的计时器，频率可变。</p><p>在了解了<code>System.currentTimeMillis</code>为什么慢以后，接下来看看它到底有多慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> times = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System.currentTimeMillis 耗时: &quot;</span> + (end1 - start1) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成<code>10000</code>、<code>100000</code>、<code>1000000</code>分别耗时<code>4ms</code>、<code>6ms</code>、<code>10ms</code>，耗时还是比较长的。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p><code>System.currentTimeMillis</code>慢的原因是底层调用的系统级别的获取时间戳的方法，既然如此，那么我们就绕开系统底层，我们走内存。一个显而易见的方式是：第一次调用<code>System.currentTimeMillis</code>方法记录下这个时间戳，然后启动一个定时任务，每隔<code>1ms</code>去更新一下这个时间戳，当有需要获取这个时间戳的时候就直接从内存里面 拿现成的，而不用找系统获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停顿时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong now;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SystemClock</span><span class="params">(<span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.now = <span class="keyword">new</span> AtomicLong(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类持有 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SystemClock INSTANCE = <span class="keyword">new</span> SystemClock(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单线程定时轮询任务，每1毫秒更新一次时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleClockUpdating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">&quot;System Clock&quot;</span>);</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; now.set(System.currentTimeMillis()), period, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看时间对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> times = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = SystemClock.now();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System.currentTimeMillis 耗时: &quot;</span> + (end1 - start1) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System Clock 耗时: &quot;</span> + (end2 - start2) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成<code>100000</code>、<code>1000000</code>、<code>10000000</code>、<code>100000000</code>个时间戳耗时对比</p><table><thead><tr><th>数量</th><th>System.currentTimeMillis</th><th>SystemClock</th></tr></thead><tbody><tr><td>100000</td><td>7ms</td><td>2ms</td></tr><tr><td>1000000</td><td>13ms</td><td>4ms</td></tr><tr><td>10000000</td><td>45ms</td><td>7ms</td></tr><tr><td>100000000</td><td>485ms</td><td>41ms</td></tr></tbody></table><p>可见在性能上，<code>SystemClock</code>确实强了很多。</p><h2 id="优化方案问题"><a href="#优化方案问题" class="headerlink" title="优化方案问题"></a>优化方案问题</h2><p>虽然优化后的方案在性能上比原来的传统方式快了很多，但是也有一个很明显的问题：<strong>精度缺失</strong>，新方案并不能保证每次获取到的时间戳都是最新的，因此很有可能多个线程获取到的时间戳是同一个时间戳。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
