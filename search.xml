<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL JOIN执行细节</title>
      <link href="2020/10/08/1ceae895"/>
      <url>2020/10/08/1ceae895</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然间看到这一篇博客《<a href="https://segmentfault.com/a/1190000015572505">Mysql - JOIN详解</a>》，其中有一部分是对联表过程的描述，这段描述看完以后感觉怪怪的，如下:</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://i.loli.net/2020/10/08/ucHMS5lYomRaDbi.png" alt="3__8CHW8T~ZITUX9MYVE_@T.png"></p><p>如果两个表的数据量都在百万级别，那么照这个说法，先来一次笛卡尔积，得到的<code>vt1</code>表将是十万亿+级别的，这直接就可以把内存搞炸了吧……</p><p>之后看了其它的博客和官方文档以后，JOIN是通过两种算法<code>Nested-Loop Join</code>和<code>Block Nested-Loop Join</code>实现的</p><h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested-Loop Join"></a>Nested-Loop Join</h2><p>当ON条件使用索引时，采用的是<code>Nested-Loop Join</code>算法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_student.*, t_score.* <span class="keyword">FROM</span> t_student <span class="keyword">JOIN</span> t_score <span class="keyword">ON</span> t_student.stu_id = t_score.stu_id <span class="keyword">WHERE</span> t_student.stu_id = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>假设在<code>stu_id</code>上加了索引，那么这个JOIN的过程是这样的（假设以<code>t_student</code>做驱动表）：</p><ol><li><p>根据条件<code>t_student.stu_id = &#39;1&#39;</code>从<code>t_student</code>中获取对应的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_student</code>的数据</p></li><li><p>根据这一行数据的<code>stu_id</code>与<code>t_score</code>关联，获取<code>t_score</code>的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_score</code>的数据</p></li><li><p>将两行数据组成一条完整的结果，存入<code>NET BUFFER</code>中</p></li><li><p>重复上述过程，直到<code>t_student</code>没有满足条件的行为止</p></li></ol><p>从上述的描述中可以看出，要查询出数据每次都要进行回表操作，而回表操作是随机IO，性能上面肯定不行。MySQL对这一步做了一些优化，操作系统读取数据的时候，不是指定了<code>id=xxx</code>就只会给你读这一条数据出来，而是一次加载一页的数据，也就是这条数据周边的其它数据也一起加载进来了。基于此，在第2步和第4步的时候，不会立刻去回表查询，而是先存入<code>read_md_buffer</code>，按照主键排序以后，再去回表查询，这样有可能下一条需要查询的数据在上一次查询的时候已经加载进内存了，节省了IO的次数。</p><h2 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h2><p>如果没有使用索引的话，那么就在只能做全表扫描了，还是原来的SQL，仍然假设<code>t_student</code>做驱动表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_student.*, t_score.* <span class="keyword">FROM</span> t_student <span class="keyword">JOIN</span> t_score <span class="keyword">ON</span> t_student.stu_id = t_score.stu_id <span class="keyword">WHERE</span> t_student.stu_id = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><ol><li><p>根据条件<code>t_student.stu_id = &#39;1&#39;</code>从<code>t_student</code>中获取对应的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_student</code>的数据，放入<code>JOIN BUFFER</code></p></li><li><p>再根据<code>JOIN BUFFER</code>中的数据，根据ON条件对<code>t_score</code>做全表扫描，找出符合条件的值</p></li><li><p>如果<code>t_student</code>表的数据没有扫描完，清空<code>JOIN BUFFER</code>，继续扫描<code>t_student</code>，重复</p></li></ol><h2 id="驱动表为什么一定是小表"><a href="#驱动表为什么一定是小表" class="headerlink" title="驱动表为什么一定是小表"></a>驱动表为什么一定是小表</h2><div class="note info simple"><p>暂且忽略可能的回表操作</p></div><p>MySQL JOIN的情况分为使用了索引和未使用索引这两种情况，假设驱动表行数为N，被驱动表行数为M</p><ol><li>使用索引的情况<ul><li>首先对驱动表根据条件做一次全表扫描，扫描行数为N</li><li>接着根据索引查询被驱动表，扫描行数为$N * \log_2M$</li><li>总的次数为$N + N * \log_2M$</li></ul></li><li>不适用索引的情况<ul><li>假设驱动表分段放入JOIN BUFFER需要分成K段，$K = \lambda * N$</li><li>总的扫描次数是$N + \lambda * N * M$</li></ul></li></ol><p>从上述两种情况来看，N或者M越小，扫描次数就越少，效率也就越高。减小N对于减小次数的幅度会比减小M的更大一些，因此驱动表选择小表更合适</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题</title>
      <link href="2020/10/08/af355a99"/>
      <url>2020/10/08/af355a99</url>
      
        <content type="html"><![CDATA[<h2 id="0001-两数之和"><a href="#0001-两数之和" class="headerlink" title="0001 两数之和"></a>0001 两数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%AE%80%E5%8D%95-green" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://img.shields.io/badge/%E5%88%86%E7%B1%BB-%E6%95%B0%E7%BB%84-blue" /></div><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><div class="tabs" id="0001"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0001-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0001-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0001-1"><p>最简单的方法就是两层循环遍历，直到找到符合条件的组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">int</span> n2 = target - n1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == n2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0001-2"><p>第一种做法显然会比较耗时一点，其耗时主要体现在需要重复的去寻找匹配的值，这个值可能是不存在的，那么这里就要做一次无用功。为了节省这一部分时间，可以将值全部通过hash散列存储起来，之后查找的时候就可以在O(1)时间复杂度内找到对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">int</span> n2 = target - n1;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(n2)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0002-两数相加"><a href="#0002-两数相加" class="headerlink" title="0002 两数相加"></a>0002 两数相加</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E4%B8%AD%E7%AD%89-orange" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://img.shields.io/badge/%E5%88%86%E7%B1%BB-%E9%93%BE%E8%A1%A8-blue" /></div><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><div class="tabs" id="0002"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0002-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0002-1"><p>很简单的一个链表相加的算式，唯一需要注意的地方是最后的结果可能有进位需要单独处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p1 = l1, p2 = l2, curr = res;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> || p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = p1 == <span class="keyword">null</span> ? <span class="number">0</span> : p1.val;</span><br><span class="line">        <span class="keyword">int</span> val2 = p2 == <span class="keyword">null</span> ? <span class="number">0</span> : p2.val;</span><br><span class="line">        p1 = p1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : p1.next;</span><br><span class="line">        p2 = p2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : p2.next;</span><br><span class="line">        <span class="keyword">int</span> sum = flag + val1 + val2;</span><br><span class="line">        flag = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0004-寻找两个正序数组的中位数"><a href="#0004-寻找两个正序数组的中位数" class="headerlink" title="0004 寻找两个正序数组的中位数"></a>0004 寻找两个正序数组的中位数</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E5%9B%B0%E9%9A%BE-red" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://img.shields.io/badge/%E5%88%86%E7%B1%BB-%E6%95%B0%E7%BB%84-blue" /></div><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p><p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><p>示例 1：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0,0], nums2 = [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [], nums2 = [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2], nums2 = []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums1.length == m</span><br><span class="line">nums2.length == n</span><br><span class="line">0 &lt;= m &lt;= 1000</span><br><span class="line">0 &lt;= n &lt;= 1000</span><br><span class="line">1 &lt;= m + n &lt;= 2000</span><br><span class="line">-106 &lt;= nums1[i], nums2[i] &lt;= 106</span><br></pre></td></tr></table></figure><div class="tabs" id="0004"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0004-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0004-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0004-1"><p>最简单的就是合并两个数组了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = merge(nums1, nums2);</span><br><span class="line">    <span class="keyword">if</span> (nums.length % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>] / <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (nums[nums.length / <span class="number">2</span>] + nums[nums.length / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] mergeArr = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + nums2.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            mergeArr[index++] = nums1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeArr[index++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length) &#123;</span><br><span class="line">        mergeArr[index++] = nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums2.length) &#123;</span><br><span class="line">        mergeArr[index++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0004-2"><p>其实并不需要合并两个数组，他们本身是有序的，如果总的长度是奇数，那么只要找到中间那个就好，否则找到中间那两个。实际上就是比较小的数丢掉<code>len / 2</code>个，然后取<code>len / 2 + 1</code>或者后面两个数的平均数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length, len2 = nums2.length, len = len1 + len2;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt;= len / <span class="number">2</span>; index++) &#123;</span><br><span class="line">        left = right;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1 &amp;&amp; (j &gt;= len2 || nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">            right = nums1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法实现</title>
      <link href="2020/10/08/9f76ab7a"/>
      <url>2020/10/08/9f76ab7a</url>
      
        <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>雪花算法生成的id总共由64位组成，其每个部分如图所示：</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://i.loli.net/2020/09/17/9Iaefb4S8EwNL3F.png" alt="13382703-b64e38457ddd13e2.png"></p><p><code>1bit</code>: 二进制中最高位是符号位，用于确定数值的正负，0代表正数，1代表负数。一般而言<code>id</code>都是正数，所以最高位这边的<code>0</code>一般是不会动的。</p><p><code>41bit</code>: 接下来的<code>41bit</code>用于记录时间戳（毫秒级），41位可以表示$2^{41} - 1$个数字，换算成年就是$(2^{41} - 1) / (1000 * 60 * 60 * 60 * 24 * 365) = 69$年</p><p><code>10bit</code>: 接下来的<code>10bit</code>用于区分不同的机器，因为系统可能不止一台机器，每一台机器生成<code>id</code>的时间戳有可能相同，因此需要标记不同的机器。<code>10bit</code>分<code>5bit</code>的<code>centerId</code>和<code>5bit</code>的<code>workerId</code>。</p><p><code>12bit</code>: 序列号是用来记录同一毫秒内产生的不同的id。一台机器有可能在同一毫秒内会产生多个id。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳 2020-01-01 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimeStamp = <span class="number">1577808000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id占据的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据表时id所占位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大支持的workerId 31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大支持的dataCenterId 31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDataCenterId = ~(-<span class="number">1L</span> &lt;&lt; dataCenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号所占位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识起始位置（从右往左数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳标识起始位置（从右往左数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStampShift = sequenceBits + workerIdBits + dataCenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号掩码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一次生成的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> dataCenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;WorkerId Can Not Greater Than %s Or Less Than 0&quot;</span>, workerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;DataCenterId Can Not Greater Than %s Or Less Than 0&quot;</span>, dataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个id 线程安全的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取的时间戳有精度缺失的问题</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = SystemClock.now();</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">// 有可能出现了系统时钟回退</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock Move Backwards, Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">// 同一毫秒，毫秒内序列化id</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 序列化耗尽，阻塞直到获取到下一个时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimeStamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新的毫秒值 重置序列号</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimeStamp = timestamp;</span><br><span class="line">        <span class="keyword">return</span> ((lastTimeStamp - startTimeStamp) &lt;&lt; timeStampShift)</span><br><span class="line">                | (dataCenterId &lt;&lt; dataCenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdBits)</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一毫秒，获取新的毫秒值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimeStamp 最后一次获取到毫秒值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个毫秒值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimeStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = -<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            timestamp = SystemClock.now();</span><br><span class="line">        &#125; <span class="keyword">while</span> (timestamp &lt;= lastTimeStamp);</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System.currentTimeMillis优化</title>
      <link href="2020/10/08/84d1ebba"/>
      <url>2020/10/08/84d1ebba</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前开发的时候经常使用<code>System.currentTimeMillis</code>来获取当前的时间戳，刚好解决雪花算法生成重复ID的时候看到了这个的优化，好奇之下对这个优化及进行了探索。</p><h2 id="System-currentTimeMillis为什么慢"><a href="#System-currentTimeMillis为什么慢" class="headerlink" title="System.currentTimeMillis为什么慢"></a>System.currentTimeMillis为什么慢</h2><p>为什么<code>System.currentTimeMillis</code>会耗时呢？有一篇<a href="https://pzemtsov.github.io/2017/07/23/the-slow-currenttimemillis.html">文章</a>对这个做了解释。简而言之就是：调用底层的获取时间戳的方法需要<strong>从用户态切换到内核态</strong>，而且这个获取时间戳的方法还受到Linux计时器的影响（Linux系统中只有一个计时器）如果并发访问的情况下，会出现资源争抢激烈的情况。</p><p>Linux计时器分为两种：HPET和TSC，HPET性能较差，因为HPET通过串行来处理并发请求，TSC性能稍好一点，会有专门的寄存器记录时间，缺点是稳定性不好，因为TSC是存硬件的计时器，频率可变。</p><p>在了解了<code>System.currentTimeMillis</code>为什么慢以后，接下来看看它到底有多慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> times = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System.currentTimeMillis 耗时: &quot;</span> + (end1 - start1) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成<code>10000</code>、<code>100000</code>、<code>1000000</code>分别耗时<code>4ms</code>、<code>6ms</code>、<code>10ms</code>，耗时还是比较长的。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p><code>System.currentTimeMillis</code>慢的原因是底层调用的系统级别的获取时间戳的方法，既然如此，那么我们就绕开系统底层，我们走内存。一个显而易见的方式是：第一次调用<code>System.currentTimeMillis</code>方法记录下这个时间戳，然后启动一个定时任务，每隔<code>1ms</code>去更新一下这个时间戳，当有需要获取这个时间戳的时候就直接从内存里面 拿现成的，而不用找系统获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停顿时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong now;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SystemClock</span><span class="params">(<span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.now = <span class="keyword">new</span> AtomicLong(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类持有 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SystemClock INSTANCE = <span class="keyword">new</span> SystemClock(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单线程定时轮询任务，每1毫秒更新一次时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleClockUpdating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">&quot;System Clock&quot;</span>);</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; now.set(System.currentTimeMillis()), period, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看时间对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> times = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = SystemClock.now();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System.currentTimeMillis 耗时: &quot;</span> + (end1 - start1) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System Clock 耗时: &quot;</span> + (end2 - start2) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成<code>100000</code>、<code>1000000</code>、<code>10000000</code>、<code>100000000</code>个时间戳耗时对比</p><table><thead><tr><th>数量</th><th>System.currentTimeMillis</th><th>SystemClock</th></tr></thead><tbody><tr><td>100000</td><td>7ms</td><td>2ms</td></tr><tr><td>1000000</td><td>13ms</td><td>4ms</td></tr><tr><td>10000000</td><td>45ms</td><td>7ms</td></tr><tr><td>100000000</td><td>485ms</td><td>41ms</td></tr></tbody></table><p>可见在性能上，<code>SystemClock</code>确实强了很多。</p><h2 id="优化方案问题"><a href="#优化方案问题" class="headerlink" title="优化方案问题"></a>优化方案问题</h2><p>虽然优化后的方案在性能上比原来的传统方式快了很多，但是也有一个很明显的问题：<strong>精度缺失</strong>，新方案并不能保证每次获取到的时间戳都是最新的，因此很有可能多个线程获取到的时间戳是同一个时间戳。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
