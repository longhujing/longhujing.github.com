<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dubbo重试+Redis连接配置问题打炸线上服务</title>
      <link href="2021/02/10/e85f6e9d.html"/>
      <url>2021/02/10/e85f6e9d.html</url>
      
        <content type="html"><![CDATA[<p>前几天产品突然接到前端反馈说收不打考勤微信通知信息了，一看线上的服务早已OOM，GG了，保留现场后赶紧先重启服务恢复一下。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>主要异常信息如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;elastic-apm-metrics-reporter&quot;</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Exception in thread &quot;Abandoned connection cleanup thread&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Exception in thread &quot;MQClientFactoryScheduledThread&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Exception in thread &quot;NettyServerBoss-thread-1&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Exception in thread &quot;dubbo-remoting-client-heartbeat-thread-1&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DubboProviderLogFilter.java:65] *********************** provider biz error, elapsed[3921715]ms, 异常源头:*********************** , 应用名: ***********************, 业务受检异常: org.redisson.client.RedisTimeoutException: Unable to get connection! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=49, freeConnectionsAmount=0, freeConnectionsCounter=0, freezed=false, freezeReason=null, client=[addr=redis://***********************], nodeType=MASTER, firstFail=0]]], command: (EVAL), command params: [local value = redis.call(&#x27;hget&#x27;, KEYS[1], ARGV[2]); local expireDate = 92233720368547758; if value ~..., 5, ***********************, redisson__timeout__set:&#123;***********************&#125;, redisson__idle__set:&#123;***********************&#125;, redisson__map_cache__last_access__set:&#123;***********************&#125;, &#123;***********************&#125;:redisson_options, 1612398570943, PooledUnsafeDirectByteBuf(ridx: 0, widx: 56, cap: 256)] after 1 retry attempts</span><br></pre></td></tr></table></figure><p>其实就是两个问题</p><ol><li>OOM（Out Of Memory）</li><li>Redis连接数耗尽</li></ol><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>第一个问题显然就是创建了太多的对象了，直接把内存打炸。</p><p>第二个问题主要是这边发送消息为了防止重复发送，会在Redis记录一下已经发送过的消息，连接数不够有可能是请求数太大导致的。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210210225741.png"></p><p>看了一下调用方的请求量，顶峰也就3000rpm，分摊到消息服务上面更是少之又少了，请求量感觉是根本不可能压垮线上服务才对啊。</p><p>再看看调用这个服务的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboReference</span></span><br><span class="line"><span class="keyword">private</span> WeChatService weChatService;</span><br></pre></td></tr></table></figure><p>好家伙，直接是默认的重试2次，超时时间是1s，似乎发现了导致大流量的问题所在了</p><p>大致的思路是这样的: <code>通知服务个别请求慢了一点导致部分接口调用触发重试 —&gt; 重试导致Redis压力增大，连接数不够用 -&gt; 进一步导致接口继续超时触发重试 -&gt; 后续调用几乎全部触发重试，请求量直接翻三倍 -&gt; 大量的Dubbo请求导致创建了太多的Handle对象 —&gt; 压垮内存，OOM</code></p><p>感觉思路是没问题的，那么现在就需要验证一下我的猜想是否正确了</p><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>首先复现一下Redis连接数不够的问题，也就是<code>org.redisson.client.RedisTimeoutException: Unable to get connection!</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">RedisTimeoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> WeChatService weChatService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                weChatService.sendMsg(...);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatServiceImpl</span> <span class="keyword">implements</span> <span class="title">WeChatService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 手动延时，触发Dubbo重试</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Redis相关操作</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，这样就可以模拟出之前预设的环境了，测试结果如下，按照预期出现了RedisTimeoutException。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210211001835.png"></p><p>当然为了严谨一点，这边还需要把手动延时去掉做一个对比测试，两相对比以后才能够判断真的是因为重试导致的流量激增引发的问题。</p><p>同样的，为了复现OOM的问题，添加JVM启动参数如下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xms</span>=<span class="string">50m</span></span><br><span class="line"><span class="meta">-Xmx</span>=<span class="string">50m</span></span><br></pre></td></tr></table></figure><p>其它不变的情况下进行测试，成功出现OOM的问题。线上的问题在本地复现成功。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>根据之前的问题分析来看</p><p><code>通知服务个别请求慢了一点导致部分接口调用触发重试 —&gt; 重试导致Redis压力增大，连接数不够用 -&gt; 进一步导致接口继续超时触发重试 -&gt; 后续调用几乎全部触发重试，请求量直接翻三倍 -&gt; 大量的Dubbo请求导致创建了太多的Handle对象 —&gt; 压垮内存，OOM</code></p><p>问题似乎是因为Redis超时导致的重试，然后进一步引发OOM的？那么是否可以通过取消重试以及调大Redis的连接池解决问题呢？</p><p>查阅了一下资料，根据资料的描述修改了相关的配置</p><ol><li><a href="https://github.com/redisson/redisson/wiki/16.-FAQ#q-i-saw-a-redistimeoutexception-what-does-it-mean-what-shall-i-do-can-redisson-team-fix-it">RedissonTimeOutException</a></li><li><a href="https://www.bookstack.cn/read/redisson-wiki-zh/spilt.6.2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95.md">Redisson单节点配置方式</a></li></ol><p>在把Redis的连接池从32调到64以后，其他条件不变的情况下（Dubbo依旧保留重试，手动延时依旧存在），没有出现RedisTimeoutException以及OOM的问题，问题似乎已经得到解决，但是问题真的解决了吗？</p><p>再次回顾一下问题，是因为Dubbo重试导致的流量激增，即大流量导致的创建过多的Handle导致的内存耗尽问题，也就是说，只要流量达到一定的程度，该炸的时候还是得炸，取消Dubbo重试和调大连接池只是缓解了问题，但是并没有解决。</p><p>其实解决问题的办法很简单，使用MQ削峰就好了。改造架构流程如图所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210211011508.png"></p><p>如此一来，通过MQ的削峰操作，即便再大的流量，也能够从容的处理。这里一个比较担心的问题就是：会不会出现消息堆积的问题？</p><p>从2020年9月份的数据来看，通知服务顶峰时期是1100rpm，这边有两台机器，那么QPS就是 <code>1100 / 60 / 2 -&gt; 9</code>，而处理一个通知大部分的耗时都是在100ms左右，那么实际上是完全可以承受住这个流量的，不会出现消息堆积的问题（出现消息堆积就会导致后面的通知出现比较严重的延时，用户要求的实时性比较高），因此这一方面的顾虑也打消了。</p><p>另外一点就是容错，Dubbo这边重试就是为了做容错，比如说网络问题或者像这种Redis处理失败的情况，可能是偶发的，因此需要重试一下。那么这边切换成MQ之后，而需要有一个容错的机制，而MQ消息消费失败了以后还可以重试消费，这就很完美了。</p><p>最后一个比较重要的问题就是还需要有失败告警机制，一旦再出现这种问题，可以提前预警提前处理，而不是等到前端反馈了才发现问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOM </tag>
            
            <tag> 延时 </tag>
            
            <tag> Redisson </tag>
            
            <tag> MQ </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义日志打印starter</title>
      <link href="2021/02/10/5f163ff4.html"/>
      <url>2021/02/10/5f163ff4.html</url>
      
        <content type="html"><![CDATA[<p>最近想把日志的部分封装成一个<code>springboot starter</code>，方便以后使用。然而在封装的过程中还是出现了很多的问题。</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要就是上面两个依赖，后面那个主要是为了实现在引用的时候能够有提示出现</p></li><li><p>添加一些必要的文件进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消耗时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long spendTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IP地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;api.log&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseLogProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; paths;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ATTRIBUTE_START_TIME = <span class="string">&quot;startTime&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.servlet.context-path:/&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String contextPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        request.setAttribute(ATTRIBUTE_START_TIME, System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WebLog webLog = <span class="keyword">new</span> WebLog();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = (<span class="keyword">long</span>) request.getAttribute(ATTRIBUTE_START_TIME);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> spendTime = endTime - startTime;</span><br><span class="line"></span><br><span class="line">        String queryString = request.getQueryString();</span><br><span class="line">        Map&lt;String, String[]&gt; parameters = request.getParameterMap();</span><br><span class="line">        String parameterString = MapUtils.isEmpty(parameters) ? Strings.EMPTY : JSON.toJSONString(parameters);</span><br><span class="line">        String params = StringUtils.joinWith(<span class="string">&quot;&amp;&quot;</span>, queryString, parameterString);</span><br><span class="line"></span><br><span class="line">        webLog.setMethod(request.getMethod())</span><br><span class="line">                .setUri(request.getRequestURI())</span><br><span class="line">                .setUrl(request.getRequestURL().toString())</span><br><span class="line">                .setIp(IpUtils.getIpAddress(request))</span><br><span class="line">                .setBasePath(contextPath)</span><br><span class="line">                .setParameter(params)</span><br><span class="line">                .setStartTime(startTime)</span><br><span class="line">                .setSpendTime(spendTime)</span><br><span class="line">                .setUsername(Strings.EMPTY)</span><br><span class="line">                .setResult(Strings.EMPTY);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;[webLog] &#123;&#125;&quot;</span>, JSON.toJSONString(webLog));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(WebLogInterceptor.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(BaseLogProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptorAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BaseLogProperties baseLogProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(WebLogInterceptor.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;api.log&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebLogInterceptor <span class="title">logInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebLogInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着就是在<code>resources</code>下面创建<code>META-INF/spring.factories</code>文件，只需要把<code>XXXAutoConfiguration</code>放进去就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.nanfeng.api.log.config.LogInterceptorAutoConfiguration</span><br></pre></td></tr></table></figure></li><li><p>还需要改一下<code>pom.xml</code>文件中的<code>springboot</code>打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实主要就是加了那个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不加这玩意，就会出现 cannot be opened because it does not exist 这种蜜汁错误，怀疑是<code>springboot</code>的打包方式有什么问题</p></li></ol><p>OK，到此为止已经可以开心的使用封装好的<code>starter</code>了。</p><p>然而在使用的过程中发现并不如人意，不是不能用，而是还是有点麻烦。<code>WebLogInterceptor</code>还是要自己在<code>webmvc</code>配置类里面手动添加进去，要是能把这一步也省略了就太爽了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebLogInterceptor webLogInterceptor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BaseLogProperties logProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebLogConfiguration</span><span class="params">(WebLogInterceptor webLogInterceptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                               BaseLogProperties logProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webLogInterceptor = webLogInterceptor;</span><br><span class="line">        <span class="keyword">this</span>.logProperties = logProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logProperties.isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(logProperties.getPaths())) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;[WebLogConfiguration] api.log.paths 匹配路径为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            registry.addInterceptor(webLogInterceptor).addPathPatterns(logProperties.getPaths());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说是自动引入，实际上还不是预先加载了而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(WebLogConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 annotation 的主要作用就是引入这个 <code>WebLogConfiguration</code>，至此整个starter就完成了</p><p>详细代码 <a href="https://github.com/longhujing/api-log-boot-starter">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法常见场景汇总</title>
      <link href="2021/02/03/55172f1b.html"/>
      <url>2021/02/03/55172f1b.html</url>
      
        <content type="html"><![CDATA[<p>二分法的原理就是每次取中间的值进行比较，每次丢弃一半的数据。这种算法是非常高效的，平均时间复杂度为$logN$，但是有一个限制条件就是必须是有序的。</p><p>接下来列举一些二分法场景的场景</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210204000054.png"></p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="完全有序"><a href="#完全有序" class="headerlink" title="完全有序"></a>完全有序</h3><h4 id="查找目标元素"><a href="#查找目标元素" class="headerlink" title="查找目标元素"></a>查找目标元素</h4><p>这种是最简单、也是最常见的一个场景。给定一个有序的数组和一个目标值，判断目标值是否存在，或者查找目标值的位置。</p><p>例如给定以下有序的一维数组，查找目标值是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;; target = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>对于二分算法，势必是需要定义<code>left</code>、<code>right</code>和<code>mid</code>，通过<code>mid</code>判断目标值是在左半边还是右半边。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210204221605.png"></p><p>对于当下场景而言，<code>target</code>在左半边，于是需要把<code>right</code>移动到<code>mid - 1</code>的位置，即接下来应该从<code>left ~ mid - 1</code>这个范围进行搜索，直到找到目标值为止。二分法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现部分有一个需要注意的地方是，求<code>mid</code>的时候，不能简单的就<code>(left + right) / 2</code>，主要是为了防止溢出问题。</p><h4 id="查找第一个-最后一个目标元素位置"><a href="#查找第一个-最后一个目标元素位置" class="headerlink" title="查找第一个|最后一个目标元素位置"></a>查找第一个|最后一个目标元素位置</h4><p>通过前面的简单示例，已经了解了二分法的基本原理，想象一下如果需要找到第一个或者最后一个<code>target</code>又应该怎么做呢？和普通的二分搜索又有什么区别？</p><p>以这一组数据为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, target = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>找出<code>target</code>第一次出现的位置，没有找到返回<code>-1</code></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206020653.png"></p><p>如图示，第一次的<code>mid</code>就已经找到了<code>target</code>的位置，但是显然这不是第一次的位置。<span style="color: red">第一次的位置应该在左半部分</span>，也就是说找到了目标元素以后，应该尝试继续到左半部分去寻找<code>target</code>。</p><p>同理，如果要找最后一次出现的位置，应该在找到了<code>target</code>以后，继续尝试去右半部分查找，以找出最后一次出现的位置。</p><p>具体实现代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 找到目标元素, 但是此时可能不是第一个位置, 应该继续向前查找</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            pos = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 找到目标元素, 但是此时可能不是最后一个的，应该继续向后查找</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            pos = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找第一个大于目标元素的位置"><a href="#查找第一个大于目标元素的位置" class="headerlink" title="查找第一个大于目标元素的位置"></a>查找第一个大于目标元素的位置</h4><p>在<code>查找目标元素第一个|最后一个位置</code>的基础上，变种再来一个<code>第一个|最后一个大于目标元素的位置</code></p><p>假设有序数组和目标值如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, target = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206155510.png"></p><p>此时<code>nums[mid] == 3 == targer</code>，那么比<code>target</code>大的元素一定在<code>mid + 1 ~ right</code>之间，所以可以缩小范围到<code>mid + 1 ~ right</code></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206155632.png"></p><p>此时<code>nums[mid] == 4 &gt; target</code>，那么这个元素就是第一个大于目标元素的位置吗？显然不是，从图中可以看出，第一个大于目标元素的位置还在前面，因此<span style="color: red">此时需要向前搜索</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到第一个比目标值大的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchFirstOneGreaterThanTarget</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            pos = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找最后一个小于目标元素的位置"><a href="#查找最后一个小于目标元素的位置" class="headerlink" title="查找最后一个小于目标元素的位置"></a>查找最后一个小于目标元素的位置</h4><p>原理同<code>查找第一个大于目标元素的位置</code>，只不过处理逻辑需要稍微改变一下</p><p>以上一个例子为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, target = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206155510.png"></p><p>此时<code>nums[mid] == target</code>，由于现在要找的是第一个小于目标于元素的位置，因此这个元素一定在<code>left ~ mid - 1</code>的部分</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206173514.png"></p><p>巧的是现在<code>nums[mid]</code>刚好就是最后一个小于目标元素的位置，但是这个只是用例设计上的巧合，实际过程中在考虑的时候应该假设该位置还不是最后一个，所以<span style="color: red">此时需要向后搜索</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到最后一个比目标值小的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchLastOneLessThanTarget</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            pos = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分有序"><a href="#部分有序" class="headerlink" title="部分有序"></a>部分有序</h3><p>前面几个例子都是完全有序的情况，然而现实中还有很多整体无序，但是部分有序的情况也是可以运用二分的思想来完成搜索的。</p><h4 id="查找目标元素（无重复）"><a href="#查找目标元素（无重复）" class="headerlink" title="查找目标元素（无重复）"></a>查找目标元素（无重复）</h4><p>有如下数组（无重复元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, target = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206173823.png"></p><p>你会发现，无论<code>mid</code>在哪个位置，总有一边是有序的。二分法的核心就是一次淘汰一半，根据这半边的有序，一样可以做到一次淘汰半边的效果。</p><p>如何验证是否有序？由于数组总体是升序排序的（逆序也一样，只不过符号相反而已），所以判断前半部分有序的规则就是<code>nums[left] &lt; nums[mid]</code>，判断后半部分有序的规则就是<code>nums[mid] &lt; nums[right]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchPartiallyOrderedNoRepetition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 前半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 目标在前半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 目标在后半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 后半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                <span class="comment">// 目标在后半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找目标元素（有重复）"><a href="#查找目标元素（有重复）" class="headerlink" title="查找目标元素（有重复）"></a>查找目标元素（有重复）</h4><p>为什么这里要区分有重复和无重复两种类型呢？例如下面这个示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, target = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206175332.png"></p><p>二分法最核心的部分就是要能够确定一个有序的区间，对于当前这个示例来说，根本无法判断到底是前面有序还是后面有序，这样就无法舍弃掉其中一半。</p><p>像现在这种情况，我们要做的就是移动<code>left</code>或<code>right</code>指针，使其出现至少半边有序的情况，由于<code>nums[mid] == nums[left] 或 nums[mid] == nums[right]</code>，所以无论移动<code>left</code>还是<code>right</code>对结果都不会有影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchPartiallyOrderedWithRepetition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 前半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 目标在前半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 目标在后半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 后半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                <span class="comment">// 目标在后半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找最小值"><a href="#查找最小值" class="headerlink" title="查找最小值"></a>查找最小值</h4><p>以部分有序无重复的例子为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, target = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210206173823.png"></p><p>对于当前这种情况，后半部分显然是有序的，那么就可以很轻松的得到后半部分的最小值就是<code>nums[mid] = 2</code>，但是2显然不是整个数组里面的最小值，或者说2只是后半部分的最小值，因此还需要求出前半部分的最小值。</p><p>场景在抽象一点就是，求出前半部分和后半部分的最小值，然后取最小值就是最终的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchMinNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> minLeft = Integer.MAX_VALUE, minRight = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">        minLeft = nums[left];</span><br><span class="line">        minRight = binarySearchMinNum(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minLeft = binarySearchMinNum(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        minRight = nums[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(minLeft, minRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有意思的是，这里并不需要关注数组里面有没有重复的元素，因为无论是否重复，并不妨碍我们找到最小的那一个元素，这里需要和查找目标元素做区分</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="查找目标元素-1"><a href="#查找目标元素-1" class="headerlink" title="查找目标元素"></a>查找目标元素</h3><p>前面全部都是一维数组，思路相对而言都是比较简单。现有一个二维数组，<span style="color: red">二维数组的每一行都是从小到大排序的，而且每一行的第一个元素都会比上一行的最后一个元素大</span>。</p><p>你会发现其实把二维数组的每一行抽出来拼接成一行就是一个升序的一维数组，那么解法和原来的是一模一样的，只不过稍微费点事而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearchMatrix</span><span class="params">(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 行数、列数</span></span><br><span class="line">    <span class="keyword">int</span> m = nums.length, n = nums[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> i = mid / m, j = mid % n;</span><br><span class="line">        <span class="keyword">if</span> (nums[i][j] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[i][j] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ParallelStream出现的高延时问题</title>
      <link href="2021/01/31/4d65c8e1.html"/>
      <url>2021/01/31/4d65c8e1.html</url>
      
        <content type="html"><![CDATA[<p>最近业务中有一段非常简单的获取学校年级列表的接口出现了非常高的延时，延时发现最高可达<span style="color:red"><strong>900ms+</strong></span>，这是不可思议的，查看了APM的数据显示并不是基础数据的延时问题（<span style="color:red"><strong>基础数据获取只消耗了20ms ~ 30ms</strong></span>），那么一切的根因就指向了这一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GradeDto&gt; gradeDtoList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">grades.parallelStream().map(grade -&gt; &#123;</span><br><span class="line">GradeDto gradeDto = GradeConvert.INSTANCE.buildGradeDto(grade);</span><br><span class="line">    <span class="keyword">return</span> gradeDto;</span><br><span class="line">&#125;).sorted().forEachOrdered(gradeDtoList::add);</span><br></pre></td></tr></table></figure><p>咋一看这段代码感觉也不太像能够吃掉800ms+的样子，但是事实上它就做到了！</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>在经过多次尝试以后，我发现可以通过以下测试代码复现出上述的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    takeSource();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; doSomething(countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;all finished ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; retDto = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    List&lt;Integer&gt; grades = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">        grades.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grades.parallelStream().map(i -&gt; i + <span class="number">1</span>).sorted(Integer::compareTo).forEachOrdered(retDto::add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消耗完ParallelStream中ForkJoinPool的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取CPU核数</span></span><br><span class="line">        <span class="keyword">int</span> processors = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ints = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processors + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ints.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; collect = ints.parallelStream().map(i -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">&quot; start sleep ...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wake up now ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码最核心的部分就是<code>takeSource</code>，一定要消耗完所有的ForkJoinPool线程</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>直接看<code>ParallelStream</code>的源码，看看了里面到底是做了什么操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中可以看到，<code>parallelStream</code>是通过一个<code>spliterator</code>分割器对数据进行分割然后计算的流。</p><p>继续深入查看内部的实现，发现<code>StreamSupport.stream(spliterator(), true)</code>返回的流的对象实际上是一个<code>ReferencePipeline.Head</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个<code>ReferencePipeline.Head</code>对象中重写了两个我们现在需要关注的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">        sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.forEach(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">        sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.forEachOrdered(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法事实上我们只需要关心<code>forEachOrdered</code>就好了，之所以把这两个都弄出来，是因为把测试代码中的<code>forEachOrdered</code>替换成<code>forEach</code>也能够达到同样的效果，因此可以相互印证的去看内部的实现。</p><p>由于这边使用的是<code>parallelStream</code>，毫无疑问会走到<code>super.forEachOrdered(action)</code>这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">           ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">           : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中不难看出，<code>forEachOrdered</code>方法调用了<code>evaluate</code>方法，然后又因为使用的是<code>parallelStream</code>，又调用了<code>terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))</code></p><p>这里的<code>terminalOp</code>是一个接口，内部有很多的实现类</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210131115453.png"></p><p>而这边调用的实际上就是这个<code>ForEachOp</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ordered)</span><br><span class="line">        <span class="keyword">new</span> ForEachOrderedTask&lt;&gt;(helper, spliterator, <span class="keyword">this</span>).invoke();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ForEachTask&lt;&gt;(helper, spliterator, helper.wrapSink(<span class="keyword">this</span>)).invoke();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你会发现最后是调用了<code>invoke</code>方法，这个方法就是整个计算任务的核心实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">    <span class="keyword">return</span> (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">        awaitJoin(wt.workQueue, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke</code>其实又是通过<code>doInvoke</code>来实现的，最后实际执行的过程调用的是<code>doExec中的exec</code>方法</p><p>这里涉及到一个非常关键的<code>status</code>变量，先来看看这个<code>status</code>代表的是什么意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;  <span class="comment">// mask out non-completion bits</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;  <span class="comment">// short bits for tags</span></span><br></pre></td></tr></table></figure><p>总共是这几个类型，其中代表任务完成的是<code>NORMAL</code>、<code>CANCELLED</code>和<code>EXCEPTIONAL</code>（失败的也算是完成），你会发现这几个代表完成的状态值都是小于0的，也就是说，<code>status &lt; 0</code>表示任务完成了</p><p><code>exec</code>这个方法是一个抽象方法，具体一来实际的实现类来实现，主要的实现类有以下几个</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210131120049.png"></p><p>通过debug，找到最后调用的是<code>CountedCompleter</code>这个类的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    compute();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回的结果永远都是<code>false</code></p><p>再回过头来看看<code>invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">    <span class="keyword">return</span> (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">        awaitJoin(wt.workQueue, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前看代码已经知道了这个<code>exec</code>方法返回的结果一直都是<code>false</code>，所以这个<code>doExec</code>返回的<code>s</code>就会一直大于等于0（任务还没有被其它的线程设置为完成，刚刚来的时候）</p><p>由于我们已经把<code>ForkJoinPool</code>的线程耗光了，此时执行这段代码的线程是我们自己创建的线程，因此<code>doInvoke</code>后面会通过<code>externalAwaitDonw()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalAwaitDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(</span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑其实就是说把当前这个<code>ForkJoinTask</code>尝试交给<code>ForkJoinPool</code>里面的线程去完成，然后当前线程等待任务完成，问题是<code>ForkJoinPool</code>里面的线程已经被消耗完了，因此当前线程会 一直被阻塞，直到<code>ForkJoinPool</code>里面的线程空闲下来执行<code>ForkJoinTask</code>任务把当前线程给解放出来。这就是导致整个接口出现这么高延时的原因所在。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>解决整个问题很简单，把<code>ParallelStream</code>换成<code>Stream</code>就好了</p><h2 id="如何正确的使用ParallelStream"><a href="#如何正确的使用ParallelStream" class="headerlink" title="如何正确的使用ParallelStream"></a>如何正确的使用ParallelStream</h2><p>说实话，这东西并没有一个标准来衡量正不正确，只能说根据场景来判断要不要使用这个东西</p><ol><li>假设任务数量是N，执行一个任务消耗的时间是M，显然M越大，那么使用<code>ParallelStream</code>的效果就越好</li><li>任务之间是否独立？如果你的任务之间具有比较强的先后顺序或者父子关系的，那么实际上并不太适合使用<code>ParallelStream</code>，因为任务不利于拆解</li><li>任务结果是否需要保证顺序？因为这边并行处理并不能保证A一定就会在B之前处理完，所以最后的顺序肯定是无序的</li><li>是否真的有必要进行并行处理？你要搞清楚你的任务数量是多少？计算的特点是什么？如果你的任务数量就是一点点，那么实际上并不适合通过并行来处理，一般可能还不如顺序执行。如果你的任务涉及到比较耗时的I/O操作，那么通过这种方式是可以显著提升性能的</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ReentrantLock分析AQS原理</title>
      <link href="2021/01/21/ef2ef3c.html"/>
      <url>2021/01/21/ef2ef3c.html</url>
      
        <content type="html"><![CDATA[<p><code>AQS</code>全称<code>AbstractQueuedSynchronizer</code>，其主要提供了一种原子式管理线程同步状态、阻塞以及唤醒等功能的框架。例如<code>ReentrantLock</code>就是通过<code>AQS</code>实现的一个基于<code>JDK</code>的锁。</p><p>在JAVA中，实现代码块同步的方式有两种，<code>synchronized</code>和<code>ReentrantLock</code>，两者的主要区别如下</p><table><thead><tr><th></th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>支持重入</td><td>✔️</td><td>✔️</td></tr><tr><td>支持公平锁</td><td>❌</td><td>✔️</td></tr><tr><td>支持非公平锁</td><td>✔️</td><td>✔️</td></tr></tbody></table><p><code>AQS</code>类图如下所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210121233750.jpg"></p><h2 id="从ReentrantLock入手剖析AQS"><a href="#从ReentrantLock入手剖析AQS" class="headerlink" title="从ReentrantLock入手剖析AQS"></a>从ReentrantLock入手剖析AQS</h2><p>ReentrantLock的一个简单使用方式如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中涉及到最核心的两个方法: <code>lock.lock()</code>以及<code>lock.unlock()</code></p><h3 id="lock-lock"><a href="#lock-lock" class="headerlink" title="lock.lock"></a>lock.lock</h3><p>由于<code>ReentrantLock</code>支持公平锁和非公平锁两种类型的锁，而公平和非公平主要体现在竞争锁上，即主要体现在<code>lock.lock</code>这个过程中，首先以公平锁的角度分析<code>lock.lock</code>的过程。</p><p>公平锁模式下，<code>lock.lock</code>最后调用到的是<code>FairSync.lock</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code>的过程是这样的</p><ol><li>首先通过<code>tryAcquire</code>尝试获取锁</li><li>如果第一步尝试获取锁失败了，那么说明已经有其他的线程获取到锁了，那么就需要把当前线程放到<code>等待队列</code>里面去，<code>Node.EXCLUSIVE</code>代表独占的意思，即当前线程要获得一个独占锁</li><li>加入到等待队列后，下一次当前线程获取到锁以后，如果当前线程的状态是<code>interrupted</code>，那么当前线程就需要响应这个中断，所以<code>acquireQueued</code>为<code>true</code>的时候，代表当前线程在挂起的过程中，又被中断过，就需要调用<code>selfInterrupted</code>响应中断</li></ol><h4 id="AQS-中的等待队列"><a href="#AQS-中的等待队列" class="headerlink" title="AQS 中的等待队列"></a>AQS 中的等待队列</h4><p>在获取锁的过程分析中，牵涉到一个<code>等待队列</code>的东西，这个<code>等待队列</code>实际上是一个<code>CLH</code>锁队列，即<code>Craig, Landin, Hagersten</code>，这个等待队列，其实就是一个由<code>Node</code>节点组成的一个双向链表，其结构如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     +------+  prev  +------+  prev  +------+</span><br><span class="line">     |      | &lt;----- |      | &lt;----- |      |</span><br><span class="line">head |      |        |      |        |      |  tail</span><br><span class="line">     |      | -----&gt; |      | -----&gt; |      |</span><br><span class="line">     +------+  next  +------+  next  +------+</span><br></pre></td></tr></table></figure><p><code>Node</code>节点中，目前需要了解的，最重要得了两个组成部分是<code>Thread</code>和<code>WaitStatus</code>，<code>Thread</code>就是当前线程，而<code>WaitStatus</code>是当前节点的状态，其主要有四个状态</p><ol><li><code>CANCELLED</code>，值为1，表示当前节点已失效</li><li><code>SIGNAL</code>，值为-1，表示当前节点下一次会获取到锁</li><li><code>CONDITION</code>，值为-2，会在<code>阻塞队列</code>中使用</li><li><code>PROPAGATE</code>，置为-3，指示下一个acquireShared应该无条件传播</li></ol><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当前线程首先获取锁状态<code>status</code>，如果<code>status = 0</code>，说明此时还没有其它的线程获取到锁<ul><li>在改变<code>status</code>之前，还需要判断当前线程节点有没有前置节点，因为公平就是要讲究先来后到，如果有前置节点，那是不能获得锁的</li></ul></li><li>由于<code>RentrantLock</code>是可重入的，所以还需要判断当前线程和持有锁的线程是不是同一个线程，如果是，那么就是重入了，需要改变<code>status</code>的值，表示重入了，否则说明锁已经被其它的线程占有了</li></ol><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>如果线程获取锁失败了，那么此时该线程应该被挂起，等待下一次锁释放以后被唤醒去竞争锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设A、B两个线程竞争锁，A获取到锁了。对于B线程，此时应该走到第二个<code>if</code>，即挂起线程B。</p><p>挂起线程B也不是随便都能挂起的，还需要判断线程B是否能挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>挂起线程B要确保线程B所处等待队列的前一个节点是做好了唤醒准备的，即前一个节点必须是<code>SIGNAL</code>，不然到时候谁来唤醒线程B呢</li><li>另外，如果前一个节点的<code>waitStatus</code>大于0，说明该节点所处的状态是<code>CANCELLED</code>，这种节点应该被移除出等待队列</li><li>如果发现前一个节点既不是<code>SIGNAL</code>，也不是<code>CANCELLED</code>，那么就会通过CAS的方式把前一个节点的状态置为<code>SIGNAL</code></li></ol><p>整个过程，只有过程1返回的是<code>true</code>，但是由于外面是一个死循环，只要没有获取到锁，线程B最后还是要走到这个方法里面， 最终的结果就是前置节点的状态置为<code>SIGNAL</code>，返回<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂起线程的方式很简单，内部是调用了<code>UNSAFE</code>类将当前线程挂起，另外通过<code>Thread.interrupted</code>方法返回当前线程的中断状态，<span style="color:red">同时将当前线程的中断状态复位</span>。</p><p>这点是很重要的，获取线程是否需要中断还有另外一种方式就是<code>Thread.isInterrupted</code>，但是这个方法不会让中断状态复位。之所以需要复位，是因为如果我们的处理逻辑是不处理这个中断，或者处理了以后还需要当前线程继续运行的话，不复位下一次这个线程走到这个地方仍然会被判断需要中断，但是我们已经处理过中断了。</p><h3 id="lock-unlock"><a href="#lock-unlock" class="headerlink" title="lock.unlock"></a>lock.unlock</h3><p>了解了加锁机制以后，接下来再看看释放锁的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个释放锁的过程主要涉及到上面的三个方法，整个的逻辑也很简单，需要注意的就是在<code>unparkSuccessor</code>的时候，获取到下一个结点如果这个节点的<code>waitStatus &gt; 0 (canceled)</code>时，需要从尾部开始找到第一个满足条件的节点（线程），这个的主要原因是：等待队列的构造过程并不是线程安全的，他整个的过程分为两步，先做好<code>prev</code>指针，然后才做好<code>next</code>指针，这样一来如果从头开始遍历，那么很可能这个<code>next</code>指针都还不存在。</p><h3 id="公平锁与非公平锁的具体体现"><a href="#公平锁与非公平锁的具体体现" class="headerlink" title="公平锁与非公平锁的具体体现"></a>公平锁与非公平锁的具体体现</h3><p>前面分析的都是公平锁的实现，非公平锁与公平锁的主要区别在于获取锁这个地方，公平锁是排队获取的，而非公平锁可以抢占，这就是两者的主要区别，非公平锁获取锁的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下公平锁的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，非公平锁上来就是一个<code>CAS</code>操作，也就是任意一个活跃的线程都是可以有机会获取到这个锁的。而公平锁这边还要判断一下这个线程是不是等待队列里面的第一个线程，是的话才能够去通过<code>CAS</code>获取锁。这里就体现了公平与非公平。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存可见性问题</title>
      <link href="2021/01/10/d64754c3.html"/>
      <url>2021/01/10/d64754c3.html</url>
      
        <content type="html"><![CDATA[<div class="note info simple"><p>内存可见性是指：一个线程正在使用的对象状态被别的线程修改后，该线程要能够立刻感知到这种变化。</p></div><p>一个简单的内存可见性的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">new</span> Thread(demo::visibleTest).start();</span><br><span class="line">        <span class="comment">// 防止太快导致子线程还没有进入运行态状态就被修改</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// wait</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visibleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;stop success ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有可见性的问题，那么主线程这边修改了<code>stop = true</code>以后，子线程是可以打印出<code>stop success ... </code>的，但是实际上是没有打印出来，也就是主线程对变量状态的修改对于子线程是不可见的，就是内存可见性问题。</p><h2 id="是什么导致了内存可见性问题？"><a href="#是什么导致了内存可见性问题？" class="headerlink" title="是什么导致了内存可见性问题？"></a>是什么导致了内存可见性问题？</h2><p>变量是存储在硬件上的，其它线程不可见自然是硬件的锅咯</p><p>计算机有三大核心的组件：CPU、内存和硬盘（机械硬盘或者SSD），如图所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210113001511.jpg"></p><p>由于CPU、内存、硬盘的性能逐级下降，为了提升CPU的使用率，最大化的发挥CPU的性能，于是在CPU和内存之间引入了高速缓存，引入之后如图所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210113003900.jpg"></p><p>之所以要分为L1、L2、L3缓存，是因为即便是高速缓存， 其速度和CPU还是又蛮大的差距，为了进一步减小这个差距，因此在CPU核心中也设立了缓存。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210113003729.png"></p><p>在处理数据的时候，数据经过硬盘 -&gt; 内存 -&gt; L1 cache -&gt; L2 cache -&gt; L3 cache加载以后，再以逆序的方式写回内存和磁盘中。下一次在操作同一份数据的时候，难道还会再走一遍这个流程吗？当然是不会的，如果此时L1 cache或者L2 cache中有这份数据，那么就会直接从这里面读取，或者在读取内存中的数据的时候，由于变更的数据还没有写回到内存里面，导致其它的核在读取的时候读到了脏数据，都是会导致内存可见性问题。</p><p>总的来说，内存可见性问题的主要原因是缓存不一致问题。</p><h2 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="headerlink" title="如何保证缓存一致性"></a>如何保证缓存一致性</h2><p>既然内存可见性是由于缓存不一致导致的，那么就要想办法解决缓存不一致的问题了。</p><h3 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h3><p>MESI协议是一种通过定义一个状态机来保证缓存的一致性的协议，其主要定义了4种状态，主要都是针对缓存行的数据。</p><ol><li>S（Shared），共享状态。表示此时各个CPU核的缓存行中的缓存数据相同。</li><li>M（Modified），修改状态。仅当前处理器拥有这个缓存行的数据，并且数据被修改过了，一段时间后会重新写回主存，写成功以后，又会恢复到S状态。</li><li>I（Invalid），失效状态。缓存行的数据已经被其它CPU核修改了，此时持有的数据已经不是最新的数据，需要从主存中重新获取最新的数据，更新后又会恢复到S</li><li>E（exclusive），独享状态。仅当前处理器拥有该缓存行的数据，没有被修改过。</li></ol><p>协议的工作原理是这样：</p><ul><li>如果此时处于S（Shared）状态，那么需要时刻监听修改缓存行的数据变动，如果监听到了，那么设置缓存行的状态为I（Invalid）</li><li>如果处于M（Modified）状态，那么需要通知到其它处理器核缓存行已被修改，使其它核的缓存行状态置为I（Invalid），并且在其他核加载该缓存行数据前刷新到主存中。</li><li>如果处理I（Invalid）状态，那么在使用到该缓存行数据时，需要从主存中获取最新的数据，更新当前缓存行数据以及状态为S（Shared）</li><li>如果处于E（Exclusive）状态，那么在其他核加载该数据时，确保其在其他核加载前刷新到主存中。</li></ul><p>这样一来，通过MESI协议实可以解决缓存不一致的问题了，但是有个很明显的问题是：<code>由于需要保证缓存一致性，因此需要同步通知到其它的核更新缓存行的状态，这个地方会耗费很多的时间</code></p><p>因此，在硬件上面做了一层优化，修改其它核的缓存行状态不是同步的，而是异步的。这样一来其它核仅需监听缓存行更新的消息即可，而不需要发送ACK确认。</p><p>但是这样也伴随着一个问题：在其它缓存行监听到消息修改状态之前，其它核的缓存行与当前的缓存行仍然有一段时间是不一致的，即并没有完美的解决缓存不一致的问题。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>硬件层面已经没有办法保证实时的一致性，但是也提供了一种<code>内存屏障</code>的解决方案，内存屏障主要分为两类：</p><ol><li><code>Load Barrier</code>，读屏障。在指令前插入读屏障，就可以强制从主存中读取最新的缓存数据</li><li><code>Store Barrier</code>，写屏障。在指令后插入写屏障，使得更新缓存数据直接更新主存，是的其它处理器可见</li></ol><h3 id="JAVA语言级别的内存屏障"><a href="#JAVA语言级别的内存屏障" class="headerlink" title="JAVA语言级别的内存屏障"></a>JAVA语言级别的内存屏障</h3><p>JAVA语言级的内存屏障主要分为4种：<code>LoadLoad</code>、<code>StoreStore</code>、<code>LoadStore</code>、<code>StoreLoad</code></p><ol><li><code>LoadLoad</code>，对于这样的一条指令: <code>Load1; LoadLoad; Load2</code>，可以保证在执行<code>Load2</code>及其之后的读取指令之前一定会先执行<code>Load1</code>指令</li><li><code>StoreStore</code>，对于这样的一条指令: <code>Store1; StoreStore; Store2</code>，可以保证在执行<code>Store2</code>及其之后的写入指令前一定会执行<code>Store1</code>指令，保证<code>Store1</code>指令的写入结果对其它处理器是可见的</li><li><code>LoadStore</code>，对于这样的一条指令: <code>Load1; LoadStore; Store2</code>，可以保证在执行<code>Store2</code>及其之后的写入指令前一定会执行<code>Load1</code>指令</li><li><code>StoreStore</code>，对于这样的一条指令: <code>Store1; StoreStore; Store2</code>，可以保证在执行<code>Store2</code>及其之后的写入指令前一定会执行<code>Store1</code>指令，保证<code>Store1</code>指令的写入结果对其它处理器是可见的</li></ol><h4 id="volatile语义内存屏障"><a href="#volatile语义内存屏障" class="headerlink" title="volatile语义内存屏障"></a>volatile语义内存屏障</h4><ul><li>每个volatile变量的读操作前插入<code>LoadLoad</code>指令，在读操作后插入<code>LoadStore</code>指令</li><li>每个volatile变量的写操作前插入<code>StoreStore</code>指令，在写操作后插入<code>StoreLoad</code>指令</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 可见性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized实现原理</title>
      <link href="2021/01/05/6e774499.html"/>
      <url>2021/01/05/6e774499.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习并发相关的内容，学完以后深感面试那一套还是太水了，没有深度和自己的理解</p></blockquote><h2 id="从目的说起"><a href="#从目的说起" class="headerlink" title="从目的说起"></a>从目的说起</h2><p>为什么需要使用<code>synchronized</code>? 加了<code>synchronized</code>后有什么不同?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; increase()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点并发基础的都知道，最后打印出来的数字一定是小于等于<code>10000</code>的，其中的缘由就是<code>count++</code>不是一个原子性的操作，而且<code>count</code>是共享的，这里存在安全问题。</p><p>但是倘若我在<code>increase</code>方法上加一个<code>synchronized</code>关键字，最终的结果就是<code>10000</code>了。</p><p>当代码中存在线程安全问题时，需要使用到<code>synchronized</code>（当然也可以是其它的方式），使用<code>synchronized</code>后，能够保证线程安全，不会出现数据错误的问题，同时会降低代码性能，因为加锁会让并发变成串行。</p><h2 id="synchronized的使用方式"><a href="#synchronized的使用方式" class="headerlink" title="synchronized的使用方式"></a>synchronized的使用方式</h2><p><code>synchronized</code>共有3种使用方式，分别是</p><ol><li>修饰实例方法</li><li>修饰代码块</li><li>修饰静态方法</li></ol><p>三种使用方式伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种方式的主要区别是<code>synchronized</code>的作用范围不同</p><ul><li>修饰实例方法时，仅针对当前实例有效，多个实例之间互不影响，也就是说如果有实例A和实例B同时调用被<code>synchronized</code>修饰的方法，那么是不会被阻塞的。</li><li>修饰代码块时，取决于<code>lock</code>，如果<code>lock</code>在多个实例之间是共享、互斥的，那么多个实例之间会阻塞，否则互不影响</li><li>修饰静态方法时，相当于<code>lock</code>等价为<code>xxx.class</code>，即锁是当前类对象。由于当前类对象只可能被加载一个到虚拟机，因此这种情况下多个实例之间是阻塞的</li></ul><h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>多个线程之间，是怎么知道其它线程获取到了锁的呢?</p></div><p>从用法上来看，每一个线程获取到的锁从本质上来讲都是一个对象，JVM中，对象大致可以分为以下几个模块</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210107005016.jpg"></p><p>线程在获取到锁的时候，会把线程的信息存储在对象的<code>对象头</code>中，也就是图中的绿色部分。这样一来，当<code>ThreadA</code>获取到锁的时候，会把<code>ThreadA</code>的信息记录到<code>对象头</code>中，当其它线程要获取锁的时候，会去判断对象头是否有其它线程的标记信息，以此判断锁是否被其它线程占有。</p><p>结合这一个原理，就能够逆推使用方式的三种情况的作用范围为什么不同了。</p><p>对象头分为<code>Mark Word</code>和<code>Klass Pointer</code>两个部分</p><ol><li><code>Mark Word</code>: 存储运行时数据，如HashCode、GC年龄信息、锁标记信息等</li><li><code>Klass Pointer</code>: 指向该对象类元数据的指针</li></ol><p>其中<code>64位的Mark Word</code>结构如图所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210110003112.jpg" alt="64位的Mark Word的结构图"></p><p>这张图同时也说明了，锁的状态一共是4种，<code>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</code></p><h2 id="锁性能优化"><a href="#锁性能优化" class="headerlink" title="锁性能优化"></a>锁性能优化</h2><p>我们期望在保证安全的情况下，还能够保证性能。这在理论上来说是不行的有得必有失，总是要舍弃一样的。但在实际过程中这是有可能的，因为实际情况比理论要复杂一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述代码，有两个线程<code>ThreadA</code>和<code>TheradB</code>要执行，那么这里就有三种情况</p><ol><li>全程只有<code>ThreadA</code>或<code>ThreadB</code>在执行</li><li><code>ThreadA</code>和<code>ThreadB</code>交替执行</li><li><code>ThreadA</code>和<code>ThreadB</code>同时执行</li></ol><p>对于1、2其实没有必要加锁，因为这两种情况不会有线程安全问题，这两种情况下执行这段代码不仅不会有任何的好处，反而还拉低了代码的性能。</p><p>JDK自<code>1.6</code>开始，对<code>synchronized</code>做了一次优化，引入了<code>偏向锁</code>、<code>轻量级锁</code>、<code>适应性自旋锁</code>、<code>锁清除</code>、<code>锁粗化</code>等实现，进一步提升了<code>synchronized</code>的性能。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>当我们认为某段代码在多线程的情况下可能会出现线程安全问题时，我们会对这段代码进行加锁操作，但是有种情况是：如果一段时间内只有一个线程在进行操作，那么这个锁还有必要吗？由或者说，有必要一上来就整一个用户态切换到内核态执行操作的这么一个过程吗？</p><p>显然这是没有必要的，那么此时需要做的就是给这个锁加上一个所属标识即可，告知有可能的其它线程这个锁已经给当前线程获取到了。</p><p>偏向锁的加锁过程如下：</p><ol><li>检测<code>MarkWord</code>是否为无锁或者偏向锁（当前线程重复获取）状态，如果不是那么则走轻量级锁或重量级锁的流程</li><li>检测<code>MarkWord</code>的锁状态是否为无锁，如果是则通过<code>CAS</code>的方式将偏向锁线程ID替换为当前线程ID，否则走撤销偏向锁流程</li><li>否则检测<code>MarkWord</code>的偏向锁线程ID是否为当前线程ID，如果是则获取锁成功，否则走撤销偏向锁流程</li></ol><p>具体获取锁流程图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210109230904.jpg"></p><p>流程图中，线程执行完同步代码块并<span style="color:red">没有去释放偏向锁</span>，其它线程要获取到偏向锁，只有先撤销掉前一个线程获取的偏向锁之后，才能够获取到。</p><p>撤销偏向锁流程如下：</p><ol><li>等待<code>safepoint</code>（全局安全点，此时线程都处于暂停状态）</li><li>判断上一个线程是否仍然持有偏向锁，如果是，则将锁升级为轻量级锁（轻量级锁的持有者为当前持有偏向锁的线程），否则擦除<code>MarkWord</code>中的线程ID，重置为无所状态</li></ol><p>偏向锁的优点很明显：在只有一个线程的情况下，加锁没有什么额外的开销，性能很不错</p><p>偏向锁的缺点也很明显：如果有锁竞争，那么就会伴随偏向锁撤销操作，而撤销操作又要等待<code>safepoint</code>，此时就会带来性能的下降</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>没有锁竞争的情况下，采用偏向锁能够很好的提升性能，但是有的时候是虽然有锁竞争的情况，但是锁竞争又不是那么的激烈，就比如线程A和线程B，交替的获取锁这样。这似乎也没有必要整那些重量级的操作。</p><p>线程中主要可以划分为几个部分：<code>虚拟机栈</code>、<code>本地方法栈</code>、<code>程序计数器</code>等，当线程获取的锁为轻量级锁的时候，虚拟机会在当前线程的栈帧中创建一个<code>Lock Record</code>的东西，<code>Lock Record</code>结构如图所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210109233624.jpg"></p><p>线程获取轻量级锁步骤如下：</p><ol><li><p>把<code>MarkWord</code>复制到<code>Lock Record</code>中</p></li><li><p>通过<code>CAS</code>将<code>MarkWord</code>更新为指向<code>Lock Record</code>的指针，并且通过<code>CAS</code>将<code>Lock Record</code>中的<code>owner</code>指针指向<code>Mark Word</code></p><p>指向成功后如图所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20210109235830.jpg"></p></li><li><p>如果更新失败了，说明此时已经有其他的线程获取到了轻量级锁，那么此时锁膨胀为重量级锁</p></li></ol><p>轻量级锁的优点：轻量级锁的好处是在锁竞争不激烈的情况下，可以避免加重量级锁带来的开销</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁升级之后就是重量级锁，按照正常情况来说，其它尝试获取锁失败的线程此时应该被阻塞，等待获取到锁的线程释放锁，然后再去竞争锁。</p><p>很明显上述过程有一个阻塞的过程，这也会带来一定的性能开销。一般而言，同步代码块里面的执行消耗的时间都不会很长，因此可以通过一种循环尝试的方式多次去获取锁，相当于不断地主动询问所是否被释放了，而不是被动的等待告知。</p><p>然而这种操作是需要耗费CPU资源的，自然不可能让你无限制的重试下去，都是有一个限制的，默认情况下是10次自旋，可以通过<code>-XX: PreBlockSpin</code>参数修改</p><h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>自旋锁的一个问题是规则定的太死了，说了10次就不可能给你11次的自旋机会，可是如果真的就是第11次成功了怎么办呢？</p><p>此时引入了适应性自旋锁的概念，即虚拟机会根据程序“经验”判断多次自旋是否会有比较大的几率获取到锁，从而动态的修改自旋次数</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁其原理是在堆内存中创建一个<code>ObjectMonitor</code>对象，在<code>MarkWord</code>中存储指向该对象的指针。<code>ObjectMonitor</code>中有两个队列：<code>_EntryList</code>和<code>_WaitSet</code>，分别存储未获取到锁被阻塞的线程和调用<code>wait</code>方法等待被唤醒的线程，其中<code>_WaitSet</code>中的线程被获取到锁的线程调用<code>notify</code>或<code>notifyAll</code>唤醒以后，会先进入到<code>_EntryList</code>中，等待线程释放锁后竞争锁。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>锁粗化的意思就是将多个连续的同步代码块合并为一个同步代码块，组合为一个大的同步代码块，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化过后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;block2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除就是干掉锁，把一些不必要的加锁代码块删除</p><h2 id="synchronized底层实现原理"><a href="#synchronized底层实现原理" class="headerlink" title="synchronized底层实现原理"></a>synchronized底层实现原理</h2><p>同步代码块的加锁解锁底层是通过<code>monitorenter</code>和<code>monitorexit</code>实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>javap -c</code>查看编译之后的字节码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #3                  // String test</span><br><span class="line">       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: monitorexit</span><br><span class="line">      <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">      <span class="number">17</span>: astore_2</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      <span class="number">19</span>: monitorexit</span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      <span class="number">21</span>: athrow</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">          <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程尝试获取锁的时候，底层就会调用<code>monitorenter</code>指令，指令先获取到<code>MarkWord</code>里面的<code>monitor</code>，如果<code>monitor</code>的计数器为0，说明没有被其它线程获取，那么此时就会让计数器+1，获取锁成功。如果<code>monitor</code>已经被当前线程持有，那么计数器也会+1，表示锁被当前线程又获取了一次，如果是其它线程操作，那么获取锁失败后会被阻塞。</p><p>当线程执行完同步代码块的内容以后，对应调用<code>monitorexit</code>指令，<code>monitor</code>计数器会-1，当<code>monitor</code>计数器为0的时候，表示锁没有被任何其它线程持有。</p>]]></content>
      
      
      <categories>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ集群搭建(双主双从)</title>
      <link href="2020/12/24/d9a0e3ef.html"/>
      <url>2020/12/24/d9a0e3ef.html</url>
      
        <content type="html"><![CDATA[<p>本文采用当前<code>RocketMQ</code>最新版本<code>4.8.0</code>，采用两台虚拟机搭建双主双从<code>RocketMQ</code>集群</p><p>整体架构如图</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201224004914.png"></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>两台CentOS7虚拟机</p></li><li><p>下载<code>RocketMQ-4.8.0</code>安装包<a class="btn-beautify button--animated outline small" href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.8.0/rocketmq-all-4.8.0-bin-release.zip"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p></li><li><p>JDK安装</p></li></ol><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><ul><li><p>解压<code>RocketMQ</code>安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unzip rocketmq-all-4.8.0-bin-release.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果提示找不到unzip命令，可以通过 yum install unzip 安装</span></span><br></pre></td></tr></table></figure></li><li><p>移动<code>RocketMQ</code>安装包到<code>/usr/local/rocketmq</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq</span><br><span class="line">mv rocketmq-all-4.8.0-bin-release /usr/<span class="built_in">local</span>/rocketmq</span><br></pre></td></tr></table></figure></li><li><p>由于采用的是双主双从模式，因此需要修改<code>/usr/local/rocketmq/conf/2m-2s-async</code>中的几个文件</p><ol><li><p><code>clusterServer1 - 192.168.3.144 - broker-a.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属集群名称</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment"># 名称可重复 为了便于管理，master和所属的slave采用同一个名称</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="comment"># 0 - master | &gt;0 - slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># nameServer 服务地址列表</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.3.144:9876;192.168.3.145:9876</span></span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/usr/local/rocketmq/store/broker-a</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/usr/local/rocketmq/store/broker-a/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/usr/local/rocketmq/store/broker-a/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/usr/local/rocketmq/store/broker-a/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/usr/local/rocketmq/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/usr/local/rocketmq/store/abort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="attr">sendMessageThreadPoolNums</span>=<span class="string">128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="attr">pullMessageThreadPoolNums</span>=<span class="string">128</span></span><br></pre></td></tr></table></figure></li><li><p><code>clusterServer1 - 192.168.3.144 - broker-b-s.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属集群名称</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment"># 名称可重复 为了便于管理，master和所属的slave采用同一个名称</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="comment"># 0 - master | &gt;0 - slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># nameServer 服务地址列表</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.3.144:9876;192.168.3.145:9876</span></span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10920</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/usr/local/rocketmq/store/broker-b-s</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/usr/local/rocketmq/store/broker-b-s/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/usr/local/rocketmq/store/broker-b-s/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/usr/local/rocketmq/store/broker-b-s/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/usr/local/rocketmq/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/usr/local/rocketmq/store/abort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="attr">sendMessageThreadPoolNums</span>=<span class="string">128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="attr">pullMessageThreadPoolNums</span>=<span class="string">128</span></span><br></pre></td></tr></table></figure></li><li><p><code>clusterServer2 - 192.168.3.145 - broker-b.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属集群名称</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment"># 名称可重复 为了便于管理，master和所属的slave采用同一个名称</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="comment"># 0 - master | &gt;0 - slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># nameServer 服务地址列表</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.3.144:9876;192.168.3.145:9876</span></span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/usr/local/rocketmq/store/broker-b</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/usr/local/rocketmq/store/broker-b/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/usr/local/rocketmq/store/broker-b/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/usr/local/rocketmq/store/broker-abindex</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/usr/local/rocketmq/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/usr/local/rocketmq/store/abort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="attr">sendMessageThreadPoolNums</span>=<span class="string">128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="attr">pullMessageThreadPoolNums</span>=<span class="string">128</span></span><br></pre></td></tr></table></figure></li><li><p><code>clusterServer2 - 192.168.3.145 - broker-a-s.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属集群名称</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment"># 名称可重复 为了便于管理，master和所属的slave采用同一个名称</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="comment"># 0 - master | &gt;0 - slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># nameServer 服务地址列表</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.3.144:9876;192.168.3.145:9876</span></span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10920</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/usr/local/rocketmq/store/broker-a-s</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/usr/local/rocketmq/store/broker-a-s/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/usr/local/rocketmq/store/broker-a-s/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/usr/local/rocketmq/store/broker-a-s/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/usr/local/rocketmq/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/usr/local/rocketmq/store/abort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="attr">sendMessageThreadPoolNums</span>=<span class="string">128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="attr">pullMessageThreadPoolNums</span>=<span class="string">128</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>创建相关文件夹</p><p>对于<code>clusterServer1 - 192.168.3.144</code> 执行如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/rocketmq/store/broker-a /usr/<span class="built_in">local</span>/rocketmq/store/broker-a/nsumequeue /usr/<span class="built_in">local</span>/rocketmq/store/broker-a/commitlog /usr/<span class="built_in">local</span>/rocketmq/store/broker-a/index /usr/<span class="built_in">local</span>/rocketmq/logs /usr/<span class="built_in">local</span>/rocketmq/store/broker-b-s /usr/<span class="built_in">local</span>/rocketmq/store/broker-b-s/nsumequeue /usr/<span class="built_in">local</span>/rocketmq/store/broker-b-s/commitlog /usr/<span class="built_in">local</span>/rocketmq/store/broker-b-s/index</span><br></pre></td></tr></table></figure><p>对于<code>clusterServer2 - 192.168.3.145</code> 执行如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/rocketmq/store/broker-a-s /usr/<span class="built_in">local</span>/rocketmq/store/broker-a-s/nsumequeue /usr/<span class="built_in">local</span>/rocketmq/store/broker-a-s/commitlog /usr/<span class="built_in">local</span>/rocketmq/store/broker-a-s/index /usr/<span class="built_in">local</span>/rocketmq/logs /usr/<span class="built_in">local</span>/rocketmq/store/broker-b /usr/<span class="built_in">local</span>/rocketmq/store/broker-b/nsumequeue /usr/<span class="built_in">local</span>/rocketmq/store/broker-b/commitlog /usr/<span class="built_in">local</span>/rocketmq/store/broker-b/index</span><br></pre></td></tr></table></figure></li><li><p>修改<code>broker</code>启动文件，降低内存配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/rocketmq/bin/runbroker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这个配置改成这样 JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>启动集群</p><ol><li><p>启动<code>clusterServer1 - 192.168.3.144 - nameServer1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh /usr/<span class="built_in">local</span>/rocketmq/bin/mqnamesrv &gt;/usr/<span class="built_in">local</span>/rocketmq/logs/mqnamesrv.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p>启动<code>clusterServer2 - 192.168.3.145 - nameServer2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh /usr/<span class="built_in">local</span>/rocketmq/bin/mqnamesrv &gt;/usr/<span class="built_in">local</span>/rocketmq/logs/mqnamesrv.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p>启动<code>clusterServer1 - 192.168.3.144 - broker-a</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh /usr/<span class="built_in">local</span>/rocketmq/bin/mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-async/broker-a.properties &gt; /usr/<span class="built_in">local</span>/rocketmq/logs/broker-a.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p>启动<code>clusterServer2 - 192.168.3.145 - broker-a-s</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh /usr/<span class="built_in">local</span>/rocketmq/bin/mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-async/broker-a-s.properties &gt; /usr/<span class="built_in">local</span>/rocketmq/logs/broker-a-s.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p>启动<code>clusterServer1 - 192.168.3.144 - broker-b</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh /usr/<span class="built_in">local</span>/rocketmq/bin/mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-async/broker-b.properties &gt; /usr/<span class="built_in">local</span>/rocketmq/logs/broker-b.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p>启动<code>clusterServer2 - 192.168.3.145 - broker-b-s</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh /usr/<span class="built_in">local</span>/rocketmq/bin/mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-async/broker-b-s.properties &gt; /usr/<span class="built_in">local</span>/rocketmq/logs/broker-b-s.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="RocketMQ-Console安装"><a href="#RocketMQ-Console安装" class="headerlink" title="RocketMQ-Console安装"></a>RocketMQ-Console安装</h3><p><code>RocketMQ</code>可以通过一个控制台查看集群信息，国内推荐使用<code>Gitee</code>镜像，<a href="https://gitee.com/mirrors/RocketMQ-Externals?_from=gitee_search">点击跳转</a></p><p>拷贝下来<code>rocketmq-console</code>项目，这个是一个<code>SpringBoot</code>项目，需要修改里面的<code>rocketmq.config.namesrvAddr</code>，配置自己的<code>nameserver</code>地址</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">rocketmq.config.namesrvAddr</span>=<span class="string">192.168.3.144:9876;192.168.3.145:9876</span></span><br></pre></td></tr></table></figure><p>使用maven打包后，上传到服务器运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-2.0.0.jar &gt;/usr/<span class="built_in">local</span>/rocketmq/logs/mq-console.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201224015012.png"></p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么使用消息队列</title>
      <link href="2020/12/15/3e803f5.html"/>
      <url>2020/12/15/3e803f5.html</url>
      
        <content type="html"><![CDATA[<p>使用消息队列当然是因为它能够带来一些好处，或者说消息队列在一些场景中，能够给系统的性能带来一定的提升</p><p>总体来说，消息队列的好处主要是: <code>解耦</code>、<code>异步</code>、<code>削峰</code></p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>在不使用消息队列的时候系统可能是这样的:</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201215003515.png" alt="image-20201215001535494"></p><p>用户在访问系统A时，系统A需要依次调用系统B、C、D才能处理完数据，系统之间耦合度较高，这样带来的一个后果就是，当业务发生变动，例如新增新的系统或者移除系统时，修改起来就是伤筋动骨。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201215003534.png" alt="image-20201215002138063"></p><p>将系统D移除以后，又新增系统E和系统F，这样一来改动整个逻辑就会非常的复杂，维护成本很高。</p><p>使用消息队列以后就会简单很多: </p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201215003551.png" alt="image-20201215002505185"></p><p>使用消息队列以后，系统A只需要将消息交给消息队列，其它的系统如果有需要就自己到消息队列获取消息处理，如果不需要了就断开和消息队列的联系即可，系统之间的耦合度降低，维护成本也降低了。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>说异步要先说同步，同步就是等待一件事完成以后再去做另一件事，例如要完成的事情是洗衣服、烧水、打游戏，总不会有人要先等衣服洗完了再去烧水，水烧好了再去打游戏吧….</p><p>一般而言都是衣服丢到洗衣机洗，然后烧水交给热水壶做，接着边打游戏便等待，这就是异步。</p><p>你会发现使用异步处理这三件事情的时候耗时不高，但是一个一个做的时候有非常的蠢。在系统中也是如此，假设一个操作需要经过A、B、C三个系统的处理，而这三个处理步骤又没有要求顺序，那么其实完全可以做异步处理而不是串行调用。</p><p>未使用消息队列前可能是这样的</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201220121636.png"></p><p>整个系统的调用时间就是B、C、D三个系统调用时间的总和</p><p>使用消息队列后是这样的</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201220122735.png"></p><p>系统A仅需把需要处理的内容发送到消息队列，剩下的事情交给关联的系统自己去读取队列内容完成处理即可，而不需要等待关联系统处理完成。</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>一般系统的架构可能是这样的</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201220123306.png"></p><p>这样的系统性能瓶颈取决于<code>MySQL</code>的性能，一般<code>MySQL</code>能够撑得住的最大就是2000QPS，如果超过这个限度系统就会崩溃。在面对大流量的情况下，一个方法是加机器、加缓存等，这样固然能够解决问题，但是代价略高，在突发高流量请求的情况下，这样的作法代价极其大，例如秒杀活动可能就是秒杀时间段流量比较高，其它时间流量都很低，为了顶住这一会儿的流量大费周章的加机器是不明智的。</p><p>这种情况最好的方式就是削峰，既然最多只能顶住2000QPS，那么就限制流量最大为2000QPS，使用消息队列削峰如下所示</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201220123923.png"></p><ol><li>假设突发流量为10000QPS，这10000QPS写入到消息队列里面</li><li>由于<code>MySQL</code>只能顶住2000QPS，那么每次只从消息队列里面拉取2000QPS的流量</li><li>在平常的时候，流量也是先进入消息队列，系统仍然保持一次最多获取2000QPS的流量，不会影响平常的使用</li></ol><p>这样一来，无论高峰期还是平时，在不加机器的情况下，都能够在保证系统稳定运行。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL分析工具-Explain</title>
      <link href="2020/12/13/34c8df5d.html"/>
      <url>2020/12/13/34c8df5d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>MySQL服务器在接收到SQL指令之后，对其进行解析会生成一个执行计划，通过Explain关键字就可以看到具体的执行计划是怎样的，从而有针对性的去优化SQL</p></blockquote><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ex_student ( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT, </span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">    student_number <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 老师信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ex_teacher ( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT, </span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">    teacher_number <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 科目表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ex_subject ( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT, </span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">    teacher_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分数表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ex_score ( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT, </span><br><span class="line">    student_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">    subject_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    score <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ex_student <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_student_number (<span class="string">`student_number`</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ex_teacher <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_teacher_number (<span class="string">`teacher_number`</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ex_subject <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_subject_teacher (<span class="string">`teacher_id`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ex_student (<span class="keyword">name</span>, student_number) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>), (<span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>), (<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;10002&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ex_teacher (<span class="keyword">name</span>, teacher_number) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhaoliu&#x27;</span>, <span class="string">&#x27;20000&#x27;</span>), (<span class="string">&#x27;ermazi&#x27;</span>, <span class="string">&#x27;20001&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ex_subject (<span class="keyword">name</span>, teacher_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;math&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;english&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;science&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ex_score (student_id, subject_id, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">80</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">60</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">70</span>), (<span class="number">2</span> ,<span class="number">2</span>, <span class="number">95</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">40</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="number">45</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure><h3 id="Explain分析"><a href="#Explain分析" class="headerlink" title="Explain分析"></a>Explain分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> ex_student;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>explain</code>分析后总共是有这些个字段: <code>id</code>、<code>select_type</code>、<code>table</code>、<code>paritions</code>、<code>type</code>、<code>possible_keys</code>、<code>key</code>、<code>key_len</code>、<code>ref</code>、<code>rows</code>、<code>filtered</code>、<code>Extra</code></p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><blockquote><p>Select 查询的序号，表示查询中查询子句或操作表的顺序，顺序从上至下</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> ex_score.* <span class="keyword">FROM</span> ex_score, ex_subject, ex_student <span class="keyword">WHERE</span> ex_score.student_id = ex_student.id <span class="keyword">AND</span> ex_score.subject_id = ex_subject.id <span class="keyword">AND</span> ex_student.id = <span class="number">1</span> <span class="keyword">AND</span> ex_subject.id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_subject | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index |</span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index |</span><br><span class="line">|  1 | SIMPLE      | ex_score   | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    9 |    11.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><ol><li><p>SIMPLE</p><p>简单的单表查询，不包含子查询或者UNION查询等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>PRIMARY</p><p>查询中含子查询，最外层的查询标记为<code>PRIMARY</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> ex_score.* <span class="keyword">FROM</span> ex_score <span class="keyword">WHERE</span> student_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>) <span class="keyword">AND</span> subject_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> ex_subject <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>);</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | PRIMARY     | ex_score   | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    9 |    11.11 | Using where |</span><br><span class="line">|  3 | SUBQUERY    | ex_subject | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index |</span><br><span class="line">|  2 | SUBQUERY    | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>SUBQUERY</p><p>和<code>PRIMARY</code>对应，查询中含子查询，不是最外层的查询标记为<code>SUBQUERY</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> ex_score.* <span class="keyword">FROM</span> ex_score <span class="keyword">WHERE</span> student_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>) <span class="keyword">AND</span> subject_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> ex_subject <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>);</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | PRIMARY     | ex_score   | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    9 |    11.11 | Using where |</span><br><span class="line">|  3 | SUBQUERY    | ex_subject | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index |</span><br><span class="line">|  2 | SUBQUERY    | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>DERIVED</p><p><code>MySQL</code>查询中，<code>FROM</code>中包含的子查询标记为<code>DERIVED</code>，<code>MySQL</code>会把查询到的结果放到临时表中。在<code>5.7+</code>的版本中做了优化，添加了<code>derived_merge</code>，默认开启，可以加快查询的效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student) <span class="keyword">AS</span> student;</span><br></pre></td></tr></table></figure></li><li><p>UNION</p><p>通过<code>UNION</code>关键字合并两个查询结果，<code>UNION</code>之后的查询语句被标记为<code>UNION</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line">| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra           |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line">|  1 | PRIMARY      | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure></li><li><p>UNION RESULT</p><p><code>UNION</code>关键字将前后的查询语句的结果合并在一起的结果，为<code>UNION RESULT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line">| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra           |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line">|  1 | PRIMARY      | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ol><li><p>NULL</p><p><code>MySQL</code>在优化阶段就能够分解掉查询语句，查询的时候无需查询表或者索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> ex_student;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | <span class="keyword">Select</span> <span class="keyword">tables</span> optimized away |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>const</p><p>仅通过索引一次就能够找到，找到之后立马返回结果，通常出现在主键索引或者唯一索引的使用上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>eq_ref</p><p>唯一性索引扫描，找到结果以后不会立马返回，还要继续扫描，常用于唯一索引查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> ex_subject.* <span class="keyword">FROM</span> ex_subject <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ex_teacher <span class="keyword">ON</span> ex_subject.teacher_id = ex_teacher.id;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+----------------------------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref                              | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+----------------------------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_subject | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                             |    3 |   100.00 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | ex_teacher | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | study_test.ex_subject.teacher_id |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+----------------------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>ref</p><p>非唯一性索引扫描，常用于普通的索引查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_subject <span class="keyword">WHERE</span> teacher_id = <span class="number">1</span>;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------------+---------------------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys       | key                 | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------------+---------------------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_subject | NULL       | ref  | idx_subject_teacher | idx_subject_teacher | 8       | const |    2 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------------+---------------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>index_merge</p><p>使用了索引合并的优化方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">OR</span> student_number = <span class="string">&#x27;10000&#x27;</span>;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------------+----------------------------+----------------------------+---------+------+------+----------+------------------------------------------------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type        | possible_keys              | key                        | key_len | ref  | rows | filtered | Extra                                                |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------------+----------------------------+----------------------------+---------+------+------+----------+------------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | index_merge | PRIMARY,idx_student_number | PRIMARY,idx_student_number | 8,130   | NULL |    2 |   100.00 | Using union(PRIMARY,idx_student_number); Using where |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------------+----------------------------+----------------------------+---------+------+------+----------+------------------------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>range</p><p>在一个范围内查询数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">2</span>;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    2 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>index</p><p>全称为<code>Full Index Scan</code>，遍历整个索引数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> ex_student;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+--------------------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key                | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+--------------------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | index | NULL          | idx_student_number | 130     | NULL |    3 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+--------------------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>all</p><p>全表查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>表示查询的表</p><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>查询可能会使用到的索引</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>查询实际使用到的索引</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>表示查询使用到的索引占用的字节数</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>表示被引用的列</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>查询可能会查询的数据量</p><h4 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h4><p>表示匹配的分区</p><h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h4><p>查询表的数据量和总数据量的比值</p><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><blockquote><p>非常重要的信息，一般根据这一列的信息对查询进行优化</p></blockquote><ol><li><p>Using filesort</p><p>查询出的数据的顺序和索引的顺序不一致，查询出来以后还要再次对数据进行排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure></li><li><p>Using temporary</p><p>MySQL对结果进行排序时，可能使用到临时表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line">| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra           |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line">|  1 | PRIMARY      | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | ex_student | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure></li><li><p>Using index</p><p>使用到了覆盖索引，查询使用到的索引包含了所有需要查询的列，就不需要回表查询了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> student_number <span class="keyword">FROM</span> ex_student <span class="keyword">WHERE</span> student_number = <span class="number">1</span>;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+--------------------+--------------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys      | key                | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+--------------------+--------------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | index | idx_student_number | idx_student_number | 130     | NULL |    3 |    33.33 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+--------------------+--------------------+---------+------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>Using where</p><p>使用到了<code>WHERE</code>的条件进行筛选</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ex_score <span class="keyword">WHERE</span> student_id = <span class="number">1</span>;</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_score | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |    11.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>Using join buffer</p><p>连表查询做笛卡尔积使用到了缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> ex_student.*, ex_teacher.* <span class="keyword">FROM</span> ex_student, ex_teacher;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | ex_teacher | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |   100.00 | NULL                                  |</span><br><span class="line">|  1 | SIMPLE      | ex_student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot线程池使用</title>
      <link href="2020/12/10/a64ce2f7.html"/>
      <url>2020/12/10/a64ce2f7.html</url>
      
        <content type="html"><![CDATA[<p>工作中有很多的场景很有必要做异步处理，如<code>更新啥啥啥又不需要即时显示的那种</code>、<code>导入数据</code>、<code>生成报表</code>等等之类的不耗时又不需要即时显示的场景。</p><h2 id="SpringBoot默认线程池"><a href="#SpringBoot默认线程池" class="headerlink" title="SpringBoot默认线程池"></a>SpringBoot默认线程池</h2><blockquote><p>In the absence of an Executor bean in the context, Spring Boot auto-configures a ThreadPoolTaskExecutor with sensible defaults that can be automatically associated to asynchronous task execution (@EnableAsync) and Spring MVC asynchronous request processing.</p></blockquote><p>这段话简单来说就是SpringBoot已经内置了一个<code>ThreadPoolTaskExecutor</code>了，如果不主动去创建这个线程池，那么就会给你默认创建一个出来，直接拿来用就可以了。比如像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor threadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">threadPoolTaskExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以下是这个默认线程池的默认参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心线程数</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.core-size</span>=<span class="string">8  </span></span><br><span class="line"><span class="comment"># 最大线程数</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.max-size</span>=<span class="string">16</span></span><br><span class="line"><span class="comment"># 空闲线程存活时间</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.keep-alive</span>=<span class="string">60s</span></span><br><span class="line"><span class="comment"># 是否允许核心线程超时</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.allow-core-thread-timeout</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 线程队列数量</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.queue-capacity</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"># 线程关闭等待</span></span><br><span class="line"><span class="meta">spring.task.execution.shutdown.await-termination</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.task.execution.shutdown.await-termination-period</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 线程名称前缀</span></span><br><span class="line"><span class="meta">spring.task.execution.thread-name-prefix</span>=<span class="string">task-</span></span><br></pre></td></tr></table></figure><h2 id="自定义创建线程池"><a href="#自定义创建线程池" class="headerlink" title="自定义创建线程池"></a>自定义创建线程池</h2><p>创建一个线程池的配置类，往Spring容器注册线程池实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;businessTaskExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">businessTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor businessTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//设置线程池参数信息</span></span><br><span class="line">        businessTaskExecutor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        businessTaskExecutor.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line">        businessTaskExecutor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        businessTaskExecutor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        businessTaskExecutor.setThreadNamePrefix(<span class="string">&quot;businessTaskExecutor-&quot;</span>);</span><br><span class="line">        businessTaskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        businessTaskExecutor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        businessTaskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">//初始化线程池</span></span><br><span class="line">        businessTaskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> businessTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用线程池的时候注意<code>对象的名称要和@Bean注解里面的名称相同</code>，不然到时候如果有多个线程池就会报错的。</p><h2 id="线程池日志打印"><a href="#线程池日志打印" class="headerlink" title="线程池日志打印"></a>线程池日志打印</h2><p>在实际环境中，使用只是比较简单和基础的一部分，运维才是最核心的部分，而运维需要日志提供相关信息才能够做下去，因此可以对<code>ThreadPoolTaskExecutor</code>进行扩展，打印日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibleThreadPoolTaskExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolTaskExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showThreadPoolInfo</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = getThreadPoolExecutor();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;, &#123;&#125;,taskCount: [&#123;&#125;], completedTaskCount: [&#123;&#125;], activeCount: [&#123;&#125;], queueSize: [&#123;&#125;]&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>.getThreadNamePrefix(),</span><br><span class="line">                prefix,</span><br><span class="line">                threadPoolExecutor.getTaskCount(),</span><br><span class="line">                threadPoolExecutor.getCompletedTaskCount(),</span><br><span class="line">                threadPoolExecutor.getActiveCount(),</span><br><span class="line">                threadPoolExecutor.getQueue().size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do execute&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">long</span> startTimeout)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do execute&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.execute(task, startTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;?&gt; submitListenable(Runnable task) &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do submitListenable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submitListenable(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">submitListenable</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do submitListenable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submitListenable(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 跨域问题解决</title>
      <link href="2020/12/09/9c514b92.html"/>
      <url>2020/12/09/9c514b92.html</url>
      
        <content type="html"><![CDATA[<p>前后端分离开发模式下，不可避免的就会出现跨域的问题。</p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p><code>URL</code>通常由以下几个部分组成</p><p><code>协议 + 域名 + 端口号 + 资源路径</code></p><p>例如<code>https://www.baidu.com/search?keyword=abc</code></p><p>就是由<code>https + www.baidu.com + 80 + /search</code>这四个部分组成，其中端口号80是默认的，就不显示出来了。如果两个<code>URL</code>中的四个部分有任意一个部分不相同，那么就会出现跨域问题。</p><h3 id="跨域亲身体会"><a href="#跨域亲身体会" class="headerlink" title="跨域亲身体会"></a>跨域亲身体会</h3><p>编写一个简单的<code>Java Web</code>服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World...1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，浏览器输入<code>http://localhost:8080/test1</code>可以看到打印出<code>Hello World...1</code></p><p>接下来，打开任意网站如：<code>http://www.baidu.com</code>，按下<code>F12</code>打开开发者工具，在<code>Console</code>出输入代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://localhost:8080/test1&#x27;</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = e.target;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Access to XMLHttpRequest at &#39;http://localhost:8080/test1&#39; from origin &#39;https://www.baidu.com&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></p><p>可以看到，发生了跨域问题，请求失败了</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="方法1-Cors跨域"><a href="#方法1-Cors跨域" class="headerlink" title="方法1 - Cors跨域"></a>方法1 - Cors跨域</h4><div class="note info simple"><p><code>Cors</code>全称<code>Cross Origin Resource Sharing（跨域资源共享）</code>，每个请求都需要一个<code>Access-Control-Allow-Origin</code>的HTTP头来允许外域的访问站点，通过这种方式可以仅暴露需要暴露的接口</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin(value = &quot;https://www.baidu.com&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World...1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原来类的基础上加上<code>@CorssOrigin</code>注解，如果注解里面的<code>value</code>为空，则表示允许所有的站点共享，否则就是指定站点共享。</p><p>重启服务再次调用原来的JS脚本尝试，<code>Console</code>正常打印<code>Hello World...1</code>说明跨域问题已经解决了。</p><h4 id="方式2-全局Cors"><a href="#方式2-全局Cors" class="headerlink" title="方式2 - 全局Cors"></a>方式2 - 全局Cors</h4><p>一个一个的配置还是太麻烦了，不如直接来一个全局的方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                        .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                        .maxAge(<span class="number">3600</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式3-过滤器实现"><a href="#方式3-过滤器实现" class="headerlink" title="方式3 - 过滤器实现"></a>方式3 - 过滤器实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;corsFilter&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, GET, PATCH, DELETE, PUT&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Desktop Manager最新版分享（持续更新）</title>
      <link href="2020/12/08/d7ec223d.html"/>
      <url>2020/12/08/d7ec223d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-Desktop-Manager-2020"><a href="#Redis-Desktop-Manager-2020" class="headerlink" title="Redis Desktop Manager 2020"></a>Redis Desktop Manager 2020</h2><div class="note info simple"><p>本文仅提供<code>Redis Desktop Manager</code>工具下载方式，如有侵权，请联系作者删除</p></div><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h3><p><code>Redis Desktop Manager 2020.0</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/i1Nqhj39tgb"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p><p><code>Redis Desktop Manager 2020.1</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/iIRBsj39r2f"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p><p><code>Redis Desktop Manager 2020.2</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/iEpukj39rmf"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p><p><code>Redis Desktop Manager 2020.3</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/isJwhj39sgf"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p><p><code>Redis Desktop Manager 2020.4</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/i1G5Hj6o8zc"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p><p><code>Redis Desktop Manager 2020.5</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/iwuxdj39swb"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p><p><code>Redis Desktop Manager 2020.6</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/iFYTJjj875i"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a><strong>MacOS</strong></h3><p><code>Redis Desktop Manager</code><a class="btn-beautify button--animated outline small" href="https://lhj8023.lanzous.com/iz6UGj6o9ud"   title="点击下载"><i class="fas fa-cloud-download-alt fa-fw"></i><span>点击下载</span></a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Redis Desktop Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git只提交某一次的Commit</title>
      <link href="2020/12/07/cc3990f2.html"/>
      <url>2020/12/07/cc3990f2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写代码有的时候会出现这样一种情况：前面已经commit了一大堆东西，但是突然有个修复需要紧急提交一下，而且又不想把前面的commit一起push，那要怎么搞哦</p></blockquote><p>如图</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201207233707.png"></p><p>我现在有以下几个<code>Commit</code>，然后我想要优先提交<code>Commit</code>信息为<code>[modify][初始化项目]</code>的这个提交，那么仅需要获取到这个提交的提交号，然后提交就好了，具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">commit 97eaf382227e744680e7de886d31293133b04308 (HEAD -&gt; master)</span><br><span class="line">Author: LHJ &lt;lhj8023@outlook.com&gt;</span><br><span class="line">Date:   Mon Dec 7 23:34:15 2020 +0800</span><br><span class="line"></span><br><span class="line">    [modify][添加RedissonRMap测试类]</span><br><span class="line"></span><br><span class="line">commit 578a3780f37df461aab44d94aedfb15ad67cf71d</span><br><span class="line">Author: LHJ &lt;lhj8023@outlook.com&gt;</span><br><span class="line">Date:   Mon Dec 7 23:33:59 2020 +0800</span><br><span class="line"></span><br><span class="line">    [modify][添加Redisson简单测试类]</span><br><span class="line"></span><br><span class="line">commit e9b25cdd12716c87ad2692d42b4339f4e3147427</span><br><span class="line">Author: LHJ &lt;lhj8023@outlook.com&gt;</span><br><span class="line">Date:   Mon Dec 7 23:33:09 2020 +0800</span><br><span class="line"></span><br><span class="line">    [modify][添加Redisson配置类]</span><br><span class="line"></span><br><span class="line">commit f6fa8ee975050f03b030b3da1a4384524ddc85ed</span><br><span class="line">Author: LHJ &lt;lhj8023@outlook.com&gt;</span><br><span class="line">Date:   Mon Dec 7 23:32:50 2020 +0800</span><br><span class="line"></span><br><span class="line">    [modify][初始化项目]</span><br></pre></td></tr></table></figure><p>可以看到想要提交的<code>Commit</code>的提交号为<code>f6fa8ee975050f03b030b3da1a4384524ddc85ed</code>，复制下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行这个命令</span></span><br><span class="line"><span class="comment"># git push 远程仓考名称 提交号:分支名称</span></span><br><span class="line"></span><br><span class="line">git push origin f6fa8ee975050f03b030b3da1a4384524ddc85ed:master</span><br></pre></td></tr></table></figure><p>这样就可以把这一个分支提交上去了，其他的分支不会一起提交</p><div class="note info simple"><p>但是，这个方法仅对第一个提交有效，也就是说如果提交不是第一个的话，那这样搞是没有用的</p></div><p>大部分时候可能想要提交的都是中间的或者最近一次的那个提交，那么就必须先把对应的提交号移动到第一个位置来，然后再按照上面的操作就可以了。</p><p>例如现在想要提交的是<code>[modify][添加Redisson配置类]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br><span class="line"></span><br><span class="line">pick f6fa8ee [modify][初始化项目]</span><br><span class="line">pick e9b25cd [modify][添加Redisson配置类]</span><br><span class="line">pick 578a378 [modify][添加Redisson简单测试类]</span><br><span class="line">pick 97eaf38 [modify][添加RedissonRMap测试类]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase a8d573d..97eaf38 onto 97eaf38 (4 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment"># .       create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment"># .       message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><p>很明显啦，接下来就只需要把<code>[modify][添加Redisson配置类]</code>移动到第一个位置就好了，移动后如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pick e9b25cd [modify][添加Redisson配置类]</span><br><span class="line">pick f6fa8ee [modify][初始化项目]</span><br><span class="line">pick 578a378 [modify][添加Redisson简单测试类]</span><br><span class="line">pick 97eaf38 [modify][添加RedissonRMap测试类]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase a8d573d..97eaf38 onto 97eaf38 (4 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment"># .       create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment"># .       message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><p>保存退出即可。</p><p><code>Successfully rebased and updated refs/heads/master.</code></p><p>接下来只需按照之前说的方式，获取到这个提交的提交号，然后单独提交就好了。</p><div class="note danger simple"><p>千万不要修改已经<code>push</code>了的提交的顺序，因为这样会搞坏你的代码仓库，处理的时候就移动你还没有<code>push</code>的东西就好了，千万千万千万不要乱来</p></div>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redisson爬坑之RMap</title>
      <link href="2020/12/06/6dd39ea8.html"/>
      <url>2020/12/06/6dd39ea8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在使用<code>Redisson</code>操作<code>Hash</code>数据结构的时候出现了很多的坑，特此记录下来。</p></blockquote><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>因为数据库表里面有<code>2000w+</code>的数据量，而业务里面查询这个表的时候有一个<code>group by</code>的操作无法走到联合索引，会造成非常大的延时（20s+），因此有必要先缓存一个月的数据在<code>Redis</code>中。按照目前的情况预估大概是有不到10个<code>key</code>，每个<code>key</code>有6000+的<code>field</code>，而且读取的时候需要一次把一个<code>key</code>下的所有<code>field</code>全部读出来。</p><h3 id="神坑操作"><a href="#神坑操作" class="headerlink" title="神坑操作"></a>神坑操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getAllRecordFromCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    RMap&lt;String, String&gt; recordMap = redissonClient.getMap(key);</span><br><span class="line">    <span class="keyword">return</span> Lists.newArrayList(recordMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看似乎没啥子问题，但是点进去这个<code>recordMap.values()</code>方法里面一看，最后是定位到这个地方来了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyPattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    Values(String keyPattern, <span class="keyword">int</span> count) &#123;</span><br><span class="line">        <span class="keyword">this</span>.keyPattern = keyPattern;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> valueIterator(keyPattern, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来最后就是通过这个<code>iteretor</code>来遍历的呀，而且这个<code>count = 10</code>，那对于目前的业务来说岂不是查一次要重复获取<code>600+</code>次? 这服务不是分分钟爆炸</p><p>接下来做一个简单的测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RMap;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonRMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = recordMap.values();</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;get total count: &quot;</span> + values.size() + <span class="string">&quot;, spend: &quot;</span> + (e - s) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            recordMap.put(String.valueOf(i), String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;finish put values ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        recordMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果耗时<code>6s+</code>! （结果因人而异，我使用的公司的<code>Redis</code>服务做的测试）这样看来都不需要上<code>jmeter</code>压测了，只要请求稍微高一点点就会直接爆炸。</p><h3 id="解决措施1"><a href="#解决措施1" class="headerlink" title="解决措施1"></a>解决措施1</h3><p>这种情况下，其实主要的耗时出现在获取<code>Redis</code>连接上，如果这方面的时间可以省下来还是比较快的，即需要做批量的处理操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RMap;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonRMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            keys.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">if</span> (keys.size() == <span class="number">100</span>) &#123;</span><br><span class="line">                values.addAll(recordMap.getAll(keys).values());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;get total count: &quot;</span> + values.size() + <span class="string">&quot;, spend: &quot;</span> + (e - s) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            recordMap.put(String.valueOf(i), String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;finish put values ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        recordMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种处理操作，可以把时间减低至400ms左右，提升还是挺大的，而且把100调成1000，还可以降低到200ms左右。虽然有所成效，但是这个时延对于<code>Redis</code>来说还是太慢了。</p><h3 id="解决措施2"><a href="#解决措施2" class="headerlink" title="解决措施2"></a>解决措施2</h3><p>第二种方法和第一种原理是一样的，都是进行批量的处理，只不过第二种用到了<code>Redisosn</code>的<code>Batch</code>操作（管道），详情请移步<a href="https://github.com/redisson/redisson/wiki/10.-%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD#103-%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C">官网</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.BatchOptions;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.BatchResult;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBatch;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RMap;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RMapAsync;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonRMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        RBatch batch = redissonClient.createBatch(BatchOptions.defaults());</span><br><span class="line">        RMapAsync&lt;String, String&gt; recordMap = batch.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            keys.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">if</span> (keys.size() == <span class="number">100</span>) &#123;</span><br><span class="line">                recordMap.getAllAsync(keys);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BatchResult&lt;?&gt; response = batch.execute();</span><br><span class="line">        List&lt;?&gt; values = response.getResponses();</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;get total count: &quot;</span> + values.size() + <span class="string">&quot;, spend: &quot;</span> + (e - s) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            recordMap.put(String.valueOf(i), String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;finish put values ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RMap&lt;String, String&gt; recordMap = redissonClient.getMap(<span class="string">&quot;recordMap&quot;</span>);</span><br><span class="line">        recordMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种处理方式的话，100这个阈值就可以达到100ms左右的时延了，比原先的方法要好上不少。</p>]]></content>
      
      
      <categories>
          
          <category> Redisson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redisson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redisson+SpringBoot简单使用</title>
      <link href="2020/12/05/8b842fbe.html"/>
      <url>2020/12/05/8b842fbe.html</url>
      
        <content type="html"><![CDATA[<p>Redis有三种操作的客户端，分别是<code>Redisson</code>、<code>Jedis</code>、<code>Lettuce</code>，<code>Jedis</code>和<code>Lettuce</code>注重于对<code>Redis</code>数据库的CRUD操作，而<code>Redisson</code>更侧重于分布式开发。详情可查看<a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">官方文档</a></p><h2 id="SpringBoot整合Redisson"><a href="#SpringBoot整合Redisson" class="headerlink" title="SpringBoot整合Redisson"></a>SpringBoot整合Redisson</h2><ol><li>引入<code>Redisson</code>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这边需要注意的是这个<code>starter</code>里面其实是有一个<code>redisson-spring-data</code>的依赖的，不同的版本对应的<code>SpringBoot</code>版本也不同，选择合适的即可。</p><table><thead><tr><th>redisson-spring-data module name</th><th>Spring Boot version</th></tr></thead><tbody><tr><td>redisson-spring-data-16</td><td>1.3.x</td></tr><tr><td>redisson-spring-data-17</td><td>1.4.x</td></tr><tr><td>redisson-spring-data-18</td><td>1.5.x</td></tr><tr><td>redisson-spring-data-20</td><td>2.0.x</td></tr><tr><td>redisson-spring-data-21</td><td>2.1.x</td></tr><tr><td>redisson-spring-data-22</td><td>2.2.x</td></tr><tr><td>redisson-spring-data-23</td><td>2.3.x</td></tr><tr><td>redisson-spring-data-24</td><td>2.4.x</td></tr></tbody></table><p>当然如果是非要用某个版本也不是不行，比如说想用目前最新的<code>redisson:3.14.0</code>，但是你的<code>SpringBoot</code>又是<code>2.2.x</code>的话，那就要这么玩了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-data-23<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-data-22<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件中配置<code>Redis</code>相关设置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><ol start="3"><li>添加<code>Redisson</code>配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就可以简单的使用<code>Redisson</code>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RList;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RList&lt;String&gt; list = redissonClient.getList(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RList&lt;String&gt; list = redissonClient.getList(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;elem1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;elem2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RList&lt;String&gt; list = redissonClient.getList(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redisson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redisson </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL提高Update效率</title>
      <link href="2020/11/30/77ad6375.html"/>
      <url>2020/11/30/77ad6375.html</url>
      
        <content type="html"><![CDATA[<p>业务中有很多的场景需要执行<code>update</code>操作，例如更新账户余额、更新库存啊balabala…</p><p>MySQL的<code>update</code>语句大致要经过以下几个步骤</p><ol><li>通过存储引擎获取到对应的行数据</li><li>将行数据加载到MySQL服务层</li><li>在服务中对行数据进行修改</li><li>将修改后的行数据通过存储引擎写回磁盘</li></ol><p>可以看出<code>update</code>的过程其实挺繁琐的，而且<code>update</code>还会伴随加锁的问题，同样会成为系统的瓶颈，比如像下面这条SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_item (</span><br><span class="line">    item_id <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    total <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t_warehouse <span class="keyword">SET</span> total = total + <span class="number">10</span> <span class="keyword">WHERE</span> item_id = <span class="string">&#x27;12345&#x27;</span>;</span><br></pre></td></tr></table></figure><p>假设在<code>item_id</code>上面加了锁，那么显然<code>update</code>这个语句是加行锁的，关键是如果多个请求都来执行这条语句的话，那么就会变成串行的执行顺序了…这样的并发其实很低。</p><p>为了提升并发能力，可以给表添加一个<code>slot</code>的概念，比如对于上面的库存表就可以设置10个<code>slot</code>，然后更新的时候这样做</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_item (</span><br><span class="line">    item_id <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    total <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    slot <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_warehouse (item_id, total, slot) <span class="keyword">VALUES</span> (<span class="string">&#x27;12345&#x27;</span>, <span class="number">10</span>, <span class="keyword">ROUND</span>(<span class="keyword">RAND</span>() * <span class="number">9</span>) + <span class="number">1</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> total = total + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这样做其实就是把原来的<code>update</code>操作转换为<code>insert</code>操作，而且可以支持最多10的并发量（可以调整）</p><p>接下来就是测试的时间了，代码已上传至<a href="https://github.com/longhujing/study_test/tree/master/mysql-update">Github</a>，有兴趣可以<code>clone</code>下来耍耍</p><p><strong>普通模式</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201205010728.jpg"></p><p><strong>SLOT模式</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201205010801.jpg"></p><p>可以看到，在并发为1000的时候，普通模式的吞吐量只有<code>347</code>，而SLOT模式可以达到<code>783</code>而且还没有异常，很明显SLOT模式的并发度是远高于普通模式的。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Order By与limit复用出现重复数据</title>
      <link href="2020/11/15/9d35a9dd.html"/>
      <url>2020/11/15/9d35a9dd.html</url>
      
        <content type="html"><![CDATA[<p>业务上需要将数据排序以后，分页查询，但是却查询出重复的数据！</p><p>案例演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_by_limit ( a <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>, b <span class="built_in">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>, create_time <span class="built_in">TIMESTAMP</span> );</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_by_limit</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;2020-11-15 00:01:00&#x27;</span> ),</span><br><span class="line">( <span class="number">2</span>, <span class="number">2</span>, <span class="string">&#x27;2020-11-15 00:00:00&#x27;</span> ),</span><br><span class="line">( <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;2020-11-15 00:00:00&#x27;</span> ),</span><br><span class="line">( <span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;2020-11-15 00:00:00&#x27;</span> ),</span><br><span class="line">( <span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;2020-11-15 00:00:00&#x27;</span> ),</span><br><span class="line">( <span class="number">6</span>, <span class="number">6</span>, <span class="string">&#x27;2020-11-15 00:00:00&#x27;</span> ),</span><br><span class="line">( <span class="number">7</span>, <span class="number">7</span>, <span class="string">&#x27;2020-11-15 00:00:00&#x27;</span> ),</span><br><span class="line">( <span class="number">8</span>, <span class="number">8</span>, <span class="string">&#x27;2020-11-15 00:00:00&#x27;</span> );</span><br></pre></td></tr></table></figure><p>要求是按照时间的升序分页获取数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_by_limit <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">2</span>;</span><br><span class="line">+<span class="comment">---+---+---------------------+</span></span><br><span class="line">| a | b | create_time         |</span><br><span class="line">+<span class="comment">---+---+---------------------+</span></span><br><span class="line">| 8 | 8 | 2020-11-15 00:00:00 |</span><br><span class="line">| 2 | 2 | 2020-11-15 00:00:00 |</span><br><span class="line">+<span class="comment">---+---+---------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_by_limit <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">limit</span> <span class="number">6</span>,<span class="number">2</span>;</span><br><span class="line">+<span class="comment">---+---+---------------------+</span></span><br><span class="line">| a | b | create_time         |</span><br><span class="line">+<span class="comment">---+---+---------------------+</span></span><br><span class="line">| 8 | 8 | 2020-11-15 00:00:00 |</span><br><span class="line">| 1 | 1 | 2020-11-15 00:01:00 |</span><br><span class="line">+<span class="comment">---+---+---------------------+</span></span><br></pre></td></tr></table></figure><p>第一页出现了<code>id = 8</code>的数据，第四页又出现了同一条数据！</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html">MySQL官方文档</a>里面的原话是这样的</p><blockquote><p>If you combine <code>LIMIT *</code>row_count<code>*</code> with <code>ORDER BY</code>, MySQL stops sorting as soon as it has found the first <em><code>row_count</code></em> rows of the sorted result, rather than sorting the entire result. If ordering is done by using an index, this is very fast. If a filesort must be done, all rows that match the query without the <code>LIMIT</code> clause are selected, and most or all of them are sorted, before the first <em><code>row_count</code></em> are found. After the initial rows have been found, MySQL does not sort any remainder of the result set.</p><p>If multiple rows have identical values in the <code>ORDER BY</code> columns, the server is free to return those rows in any order, and may do so differently depending on the overall execution plan. In other words, the sort order of those rows is nondeterministic with respect to the nonordered columns.</p></blockquote><p>意思是，如果把<code>limit</code>和<code>order by</code>复用的话，MySQL会做一次优化，不会先把全部的数据排序然后取出满足条件的数据，而是只要找到了满足条件的行就直接返回了。</p><p>如果<code>ORDER BY</code>排序行中，有重复的数据，那么MySQL就会随机返回结果，并且根据执行计划的不同返回不同的结果。</p><p>如果我就是想要<code>ORDER BY</code>和<code>LIMIT</code>一起用，又要保证不会出现重复的数据的话，那么就只能在<code>ORDER BY</code>中加入不会重复的数据列进行排序，比如加上<code>id</code>，类似这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_by_limit <span class="keyword">order</span> <span class="keyword">by</span> create_time, <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">6</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这样就不会出现重复的数据了。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logback.xml配置模板</title>
      <link href="2020/11/10/a1ed5817.html"/>
      <url>2020/11/10/a1ed5817.html</url>
      
        <content type="html"><![CDATA[<p>最近需要使用到<code>logback</code>来记录日志，苦于没有积累，游了大半天百度，先记下来留着以后用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可选：定义文件名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;PROJECT_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tortoise-blog-gateway&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址，后面通过$&#123;LOG_HOME&#125;获取，勿在 LogBack 的配置中使用相对路径，存在疑问？ 我这里使用相对地址就是当前目录下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs/$&#123;PROJECT_NAME&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件保存时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxHistory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件最大大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxFileSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 总文件大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;totalSizeCap&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50MB&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- appender 必选节点。作用：日志输出目的地， 配置后由 root 标签进行选择控制是否输出到目的地 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_PATTERN&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志依赖的渲染类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;clr&quot;</span> <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;wex&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;wEx&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoder 日志格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- appender 必选节点。作用：日志输出目的地， 配置后由 root 标签进行选择控制是否输出到目的地 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 只记录INFO级别日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- rollingPolicy 日志生成策略，不同的策略不同的类。 特别注意：尺寸切割和时间切割的日志类SizeAndTimeBasedRollingPolicy --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件输出的文件名 --&gt;</span>    <span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/info/%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每个日志文件大小，单位 kb、MB 等，这个功能控制不稳定，因为打印日志速度太快，每个文件会变大。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>$&#123;maxFileSize&#125;<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志总体积大小，超过了就会删除前面的旧日志文件腾出空间，可以边打印边看结果 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>$&#123;totalSizeCap&#125;<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoder 日志格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 只记录DEBUG级别日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- rollingPolicy 日志生成策略，不同的策略不同的类。 特别注意：尺寸切割和时间切割的日志类SizeAndTimeBasedRollingPolicy --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件输出的文件名 --&gt;</span>    <span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/debug/%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每个日志文件大小，单位 kb、MB 等，这个功能控制不稳定，因为打印日志速度太快，每个文件会变大。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>$&#123;maxFileSize&#125;<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志总体积大小，超过了就会删除前面的旧日志文件腾出空间，可以边打印边看结果 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>$&#123;totalSizeCap&#125;<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoder 日志格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 只记录WARN级别日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- rollingPolicy 日志生成策略，不同的策略不同的类。 特别注意：尺寸切割和时间切割的日志类SizeAndTimeBasedRollingPolicy --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件输出的文件名 --&gt;</span>    <span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/warn/%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每个日志文件大小，单位 kb、MB 等，这个功能控制不稳定，因为打印日志速度太快，每个文件会变大。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>$&#123;maxFileSize&#125;<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志总体积大小，超过了就会删除前面的旧日志文件腾出空间，可以边打印边看结果 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>$&#123;totalSizeCap&#125;<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoder 日志格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ERROR&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 只记录INFO级别日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- rollingPolicy 日志生成策略，不同的策略不同的类。 特别注意：尺寸切割和时间切割的日志类SizeAndTimeBasedRollingPolicy --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件输出的文件名 --&gt;</span>    <span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/error/%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每个日志文件大小，单位 kb、MB 等，这个功能控制不稳定，因为打印日志速度太快，每个文件会变大。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>$&#123;maxFileSize&#125;<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志总体积大小，超过了就会删除前面的旧日志文件腾出空间，可以边打印边看结果 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>$&#123;totalSizeCap&#125;<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoder 日志格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- root必选节点：1.基础的日志输出级别配置，2.控制那些appender输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意：全部注释了，那么不输出日志了。 但是不影响 logger 标签的配置输出。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> logback </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kong网关及Web控制台安装</title>
      <link href="2020/11/08/6b05edee.html"/>
      <url>2020/11/08/6b05edee.html</url>
      
        <content type="html"><![CDATA[<p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201108131854.svg"></p><div class="note info simple"><p>本文主要描述在<code>Centos7</code>中，如何通过<code>Docker</code>安装<code>Kong</code>网关以及Web控制台</p></div><h2 id="创建Docker网络"><a href="#创建Docker网络" class="headerlink" title="创建Docker网络"></a>创建Docker网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create kong-net</span><br></pre></td></tr></table></figure><h2 id="数据库环境准备"><a href="#数据库环境准备" class="headerlink" title="数据库环境准备"></a>数据库环境准备</h2><div class="note info simple"><p>这里使用的数据库是PostgreSQL</p><p>版本必须是9.6，不要使用太高的版本，不然后面安装控制台会报错!</p><p>这里的用户名和密码统一使用<code>kong</code>，可以自定义</p></div><h3 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e <span class="string">&quot;POSTGRES_USER=kong&quot;</span> \</span><br><span class="line">               -e <span class="string">&quot;POSTGRES_DB=kong&quot;</span> \</span><br><span class="line">               -e <span class="string">&quot;KONG_PG_PASSWORD=kong&quot;</span> \</span><br><span class="line">               -e <span class="string">&quot;POSTGRES_PASSWORD=kong&quot;</span> \</span><br><span class="line">               postgres:9.6</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -e <span class="string">&quot;KONG_DATABASE=postgres&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PG_HOST=kong-database&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PG_USER=kong&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PG_PASSWORD=kong&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> \</span><br><span class="line">     kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><h2 id="启动Kong"><a href="#启动Kong" class="headerlink" title="启动Kong"></a>启动Kong</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -e <span class="string">&quot;KONG_DATABASE=postgres&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PG_HOST=kong-database&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PG_USER=kong&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PG_PASSWORD=kong&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot;</span> \</span><br><span class="line">     -e <span class="string">&quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot;</span> \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8444:8444 \</span><br><span class="line">     kong:latest</span><br></pre></td></tr></table></figure><h3 id="测试Kong是否启动成功"><a href="#测试Kong是否启动成功" class="headerlink" title="测试Kong是否启动成功"></a>测试Kong是否启动成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://localhost:8001/</span><br></pre></td></tr></table></figure><h2 id="安装控制台"><a href="#安装控制台" class="headerlink" title="安装控制台"></a>安装控制台</h2><h3 id="kong-dashboard"><a href="#kong-dashboard" class="headerlink" title="kong-dashboard"></a>kong-dashboard</h3><div class="note info simple"><p>需要注意的是，<code>kong-dashboard</code>不支持<code>kong v2.0+</code>，高版本的<code>kong</code>请选择使用<code>konga</code></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --netword kong-net --name kong-dashboard -p 8080:8080 pgbi/kong-dashboard start --kong-url http://localhost:8001  --basic-auth kongUser=kong</span><br></pre></td></tr></table></figure><h3 id="konga"><a href="#konga" class="headerlink" title="konga"></a>konga</h3><h4 id="准备数据库环境"><a href="#准备数据库环境" class="headerlink" title="准备数据库环境"></a>准备数据库环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a postgres -u postgresql://kong:kong@localhost:5432/konga</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1337:1337 \</span><br><span class="line">        --network kong-net \</span><br><span class="line">        --name konga \</span><br><span class="line">        -e <span class="string">&quot;NODE_ENV=production&quot;</span>  \</span><br><span class="line">        -e <span class="string">&quot;DB_ADAPTER=postgres&quot;</span> \</span><br><span class="line">        -e <span class="string">&quot;DB_URI=postgresql://kong:kong@localhost:5432/konga&quot;</span> \</span><br><span class="line">        pantsel/konga</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:1337/</code>查看是否安装成功</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201108131652.png"></p>]]></content>
      
      
      <categories>
          
          <category> Kong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关 </tag>
            
            <tag> Kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitBash 主题</title>
      <link href="2020/11/03/4dbe01c1.html"/>
      <url>2020/11/03/4dbe01c1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Windows安装的GitBash初始的时候丑的一比，对于我这种追究外表、爱捣鼓一些乱七八糟玩意的人是无法接受的😂</p></blockquote><h2 id="设置GitBash主题"><a href="#设置GitBash主题" class="headerlink" title="设置GitBash主题"></a>设置GitBash主题</h2><div class="note info simple"><p>打开<code>GitBash</code>，输入命令<code>vim ~/.minttyrc</code></p></div><h3 id="主题1"><a href="#主题1" class="headerlink" title="主题1"></a>主题1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BoldAsFont&#x3D;-1</span><br><span class="line">FontHeight&#x3D;12</span><br><span class="line">Scrollbar&#x3D;none</span><br><span class="line">Term&#x3D;xterm-256color</span><br><span class="line">BoldAsColour&#x3D;yes</span><br><span class="line">Black&#x3D;7,54,66</span><br><span class="line">Red&#x3D;220,50,47</span><br><span class="line">Green&#x3D;133,153,0</span><br><span class="line">Yellow&#x3D;181,137,0</span><br><span class="line">Blue&#x3D;38,139,210</span><br><span class="line">Magenta&#x3D;211,54,130</span><br><span class="line">Cyan&#x3D;42,161,152</span><br><span class="line">White&#x3D;238,232,213</span><br><span class="line">BoldBlack&#x3D;0,43,54</span><br><span class="line">BoldRed&#x3D;203,75,22</span><br><span class="line">BoldGreen&#x3D;88,110,117</span><br><span class="line">BoldYellow&#x3D;101,123,131</span><br><span class="line">BoldBlue&#x3D;131,148,150</span><br><span class="line">BoldMagenta&#x3D;108,113,196</span><br><span class="line">BoldCyan&#x3D;147,161,161</span><br><span class="line">BoldWhite&#x3D;253,246,227</span><br><span class="line">ForegroundColour&#x3D;192,192,192</span><br><span class="line">BackgroundColour&#x3D;0,43,54</span><br><span class="line">CursorColour&#x3D;133,153,0</span><br><span class="line">Columns&#x3D;140</span><br><span class="line">Rows&#x3D;40</span><br><span class="line"></span><br><span class="line">Locale&#x3D;zh_CN</span><br><span class="line">Charset&#x3D;UTF-8</span><br><span class="line">Font&#x3D;YaHei Consolas Hybrid</span><br><span class="line">Transparency&#x3D;off</span><br><span class="line">CursorType&#x3D;block</span><br><span class="line">CursorBlinks&#x3D;yes</span><br></pre></td></tr></table></figure><p>效果就是这样啦</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201103014402.jpg"></p><h3 id="主题2"><a href="#主题2" class="headerlink" title="主题2"></a>主题2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Font&#x3D;Consolas</span><br><span class="line">FontHeight&#x3D;9</span><br><span class="line"></span><br><span class="line">BackgroundColour&#x3D;216,230,206</span><br><span class="line">ForegroundColour&#x3D;0,0,0</span><br><span class="line">CursorColour&#x3D;0,0,0</span><br><span class="line">Black&#x3D;0,0,0</span><br><span class="line">BoldBlack&#x3D;0,0,0</span><br><span class="line">Red&#x3D;130,68,6</span><br><span class="line">BoldRed&#x3D;246,155,64</span><br><span class="line">Green&#x3D;6,130,68</span><br><span class="line">BoldGreen&#x3D;64,246,155</span><br><span class="line">Yellow&#x3D;68,130,6</span><br><span class="line">BoldYellow&#x3D;155,246,64</span><br><span class="line">Blue&#x3D;68,6,130</span><br><span class="line">BoldBlue&#x3D;155,64,246</span><br><span class="line">Magenta&#x3D;130,6,68</span><br><span class="line">BoldMagenta&#x3D;246,64,155</span><br><span class="line">Cyan&#x3D;6,68,130</span><br><span class="line">BoldCyan&#x3D;64,155,246</span><br><span class="line">White&#x3D;255,255,255</span><br><span class="line">BoldWhite&#x3D;255,255,255</span><br><span class="line"></span><br><span class="line">Columns&#x3D;120</span><br><span class="line">Rows&#x3D;34</span><br><span class="line">CursorType&#x3D;block</span><br><span class="line">BoldAsFont&#x3D;-1</span><br><span class="line">FontWeight&#x3D;400</span><br><span class="line">FontIsBold&#x3D;no</span><br></pre></td></tr></table></figure><p>效果就是这样啦~</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201103014439.png"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBash </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引失效</title>
      <link href="2020/10/29/90fd26f6.html"/>
      <url>2020/10/29/90fd26f6.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是失效"><a href="#什么是失效" class="headerlink" title="什么是失效"></a>什么是失效</h2><p>明明创建好了索引，但是执行的时候却没有时用到这个索引，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`demo_table`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> demo_table <span class="keyword">WHERE</span> a = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201029014815.png"></p><p>表中，<code>a</code>为主键列，案例来说应该使用到主键索引才对，但是实际上并没有</p><h2 id="什么时候会失效"><a href="#什么时候会失效" class="headerlink" title="什么时候会失效"></a>什么时候会失效</h2><p>索引失效一共有7种情况，分别是：</p><ol><li><code>LIKE</code>查询以<code>%</code>开头</li><li><code>WHERE</code>条件中的索引列参与了计算</li><li><code>WHERE</code>条件中的索引调用了函数</li><li>索引列需要进行类型转换</li><li>复合索引未能满足<code>最左匹配原则</code></li><li>使用了<code>OR</code></li><li><code>MySQL</code>觉得没有必要走索引</li></ol><h2 id="为什么会失效"><a href="#为什么会失效" class="headerlink" title="为什么会失效"></a>为什么会失效</h2><p>要弄明白为什么会失效，首先需要搞清楚<code>MySQL</code>的索引是什么，其底层的结构是什么样的以及<code>MySQL</code>到底是怎么通过索引来检索数据的。</p><p>MySQL中的索引主要是Hash索引和B+树索引，而InnoDB中的索引就是B+树索引。总所周知，MySQL的聚簇索引每个非叶子节点存储的其实是主键值，叶子节点存储的是整行的值，而且每行之间是根据主键进行排序的。二级索引的结构和聚簇索引差不多，叶子节点上存储的是索引列的值+主键，并且也是根据索引列+主键列进行排序。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031155759.png" alt="索引结构图"></p><p>对于聚簇索引而言，查询的时候就是通过主键列的值一个一个的比较过去就可以查到了，对于非聚簇索引，那么就需要<span style="color:red">依次</span>比较索引列的值，然后最终确定到一个或多个叶子节点，如果采用的是覆盖索引，那么就可以返回了，否则还需要根据主键值来一次回表查询。</p><p>为了说明问题，使用这张表进行演示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`demo_table`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">varchar</span>(<span class="number">32</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b_c_d`</span> (<span class="string">`b`</span>, <span class="string">`c`</span>, <span class="string">`d`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><h3 id="LIKE查询失效"><a href="#LIKE查询失效" class="headerlink" title="LIKE查询失效"></a>LIKE查询失效</h3><p>LIKE查询失效指的是以<code>%</code>开头的查询才会失效，并不是所有的都会失效，比如说这个LIKE就不会失效</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031164743.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031164846.png"></p><p>但是这么玩就会失效了</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031170818.png"></p><p>也就是说，如果LIKE查询是<code>%</code>开头，那么这个索引就用不上了。</p><p>之前说过索引的结构和查询使用的过程，是通过索引列一个一个比较的，<code>%</code>的意思是可以为任意长度的字符串，那这还怎么去比较呢？毕竟需要从头比较不是</p><h3 id="索引列参与了计算或使用了函数"><a href="#索引列参与了计算或使用了函数" class="headerlink" title="索引列参与了计算或使用了函数"></a>索引列参与了计算或使用了函数</h3><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031171302.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031172817.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031173933.png"></p><p>这种情况主要是因为参与计算或者使用了函数以后，本来应该是确定的值，现在不确定了！就好比第一张图，一眼看过去就知道结果是<code>b = &#39;12&#39;</code>，但是你不能要求MySQL跟你一样聪明啊，MySQL在这种情况下只能当作一个未知数来处理，一个未知数又怎么可能根据索引去做比较呢？</p><h3 id="索引列需要进行类型转换"><a href="#索引列需要进行类型转换" class="headerlink" title="索引列需要进行类型转换"></a>索引列需要进行类型转换</h3><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031174811.png"></p><p>类型转换的原因和之前的需要计算或者使用了函数的原因相同，单独列出来是为了着重说明，因为平时很容易忽略这个问题</p><h3 id="不满足最左匹配原则"><a href="#不满足最左匹配原则" class="headerlink" title="不满足最左匹配原则"></a>不满足最左匹配原则</h3><p>最左匹配原则的意思就是，从左往右匹配呗，比如现在有的索引是<code>idx_b_c_d</code>，然后比较的时候当然就是先比较<code>b</code>，然后比较<code>c</code>，最后比较<code>d</code>这样搞。</p><p>那么不满足最左匹配原则就是没有按照上述的规则来呗</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031175222.png"></p><p>像这样，虽然<code>c</code>和<code>d</code>都在索引<code>idx_b_c_d</code>中，但是由于没有用到<code>b</code>，导致从左往右匹配的时候无法进行，因此没有使用到索引</p><h3 id="使用了OR"><a href="#使用了OR" class="headerlink" title="使用了OR"></a>使用了OR</h3><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201031175519.png"></p><p>按理来说，<code>b = &#39;2&#39; AND c = &#39;2&#39;</code>满足最左匹配原则，应该是可以使用到索引<code>idx_b_c_d</code>的，但是问题在于使用<code>b = &#39;2&#39; AND c = &#39;2&#39;</code>这个条件并不能囊括所有的可能数据，因为<code>c = 1</code>这一类的数据就没有被考虑进去，因此在这种情况下是无法使用索引的。</p><h3 id="MySQL觉得没必要走索引"><a href="#MySQL觉得没必要走索引" class="headerlink" title="MySQL觉得没必要走索引"></a>MySQL觉得没必要走索引</h3><p>之前说过二级索引的叶子节点存储的是二级索引的索引列值+主键值，如果查询的时候没有用到覆盖索引，那么就会根据主键值回表一次，这种情况下其实查询了一共2次索引</p><p>假设查询的代价是<code>n</code>，那么如果扫描一次全表的代价是<code>m</code>且<code>n &gt; m</code>的时候，MySQL就会选择走全表而不走索引了，毕竟走索引还不如走全表不是</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的日志</title>
      <link href="2020/10/18/937fe6d5.html"/>
      <url>2020/10/18/937fe6d5.html</url>
      
        <content type="html"><![CDATA[<p>MySQL操作数据的时候，每次是从磁盘中按页读取数据的，对这部分数据进行修改以后，首先会将修改放到一块内存区域<code>Buffer Pool</code>中，然后再刷到磁盘中。假如说此时发生了一些故障，比如突然断电，导致<code>Buffer Pool</code>中的一些数据还没有来得及刷到磁盘上，那不就丢失了整个<code>Buffer Pool</code>的数据？</p><p>为了避免这种情况，MySQL采用了一种<code>WAL(Write Ahead Log)</code>机制，即预写日志机制，其核心就是刷新内存之前，先把日志记录到磁盘里面永久保存，而且为了提升性能，写日志都是顺序IO。</p><p>MySQL中的日志大致有7种类型，分别是</p><p><code>redo log</code>、<code>undo log</code>、<code>bin log</code>、<code>error log</code>、<code>slow query log</code>、<code>general log</code>、<code>relay log</code></p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>有这么一种情况，一个事务已经<code>commit</code>了，但是还没有把数据刷新到磁盘，此时突然发生故障，导致这一部分数据丢失，为了让MySQL重启以后恢复到原来的状态，就需要使用<code>redo log</code>。</p><h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p>和<code>Buffer Pool</code>一样，redo log也有自己的一个缓冲池<code>redo log buffer</code>，事务执行<code>DML</code>语句的时候，会向<code>redo log buffer</code>中记录一条修改的日志，然后刷新到磁盘上的日志文件中去。</p><p>默认的，<code>redo log buffer</code>的大小是<code>16M</code>（MySQL 8.0），可以通过如下命令查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| Variable_name          | Value    |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| innodb_log_buffer_size | 16777216 |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure><p>redo log buffer 刷盘策略</p><ol><li>当事务提交的时候</li><li>当<code>redo log buffer</code>剩余空间小于一半的时候</li><li>后台线程每隔1s刷新一次</li></ol><h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><p>正常情况下，MySQL不发生任何故障，事务对数据库的修改持久化到磁盘上了，那么这一部分的<code>redo log</code>其实就没有保存的必要，留着也是浪费空间，因此<code>redo log</code>采用的是循环写的方式来记录日志。</p><p>默认的，MySQL中<code>redo log</code>日志文件是2个，可以通过如下命令查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_files_in_group%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br><span class="line">| innodb_log_files_in_group | 2     |</span><br><span class="line">+<span class="comment">---------------------------+-------+</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201018124146.png"></p><p><code>redo log</code>循环写图例如上图所示，其中有两个比较关键的变量</p><ol><li><code>write_pos</code>，表示下一次写<code>redo log</code>的位置</li><li><code>check_point</code>，表示尚未刷新到磁盘的事务修改的起始位置</li></ol><p><code>write_pos ~ check_point</code>就是目前剩余的空间，<code>check_point ~ write_pos</code>就是尚未刷新到磁盘的事务修改。</p><p>之前讲过，如果已经刷新到磁盘的事务修改，那么这一段<code>redo log</code>是没有用的，可以随便覆盖掉，但是那些还没有刷到磁盘的就不能随便乱搞了。那么这样一来就很有可能出现”追尾”的情况：<code>redo log</code>疯狂的写，但是事务修改迟迟没有刷新到磁盘里面。那么此时<code>write_pos</code>就要推着<code>check_point</code>往前走，强制让事务的修改刷新到磁盘里面去，在这个时候，MySQL是不接受任何<code>DML</code>语句的，也就会出现”抖动”。</p><h3 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h3><p>如果每一次事务<code>commit</code>后，都要把期间产生的<code>redo log</code>刷新到磁盘里面，那么这样一来虽然保证了持久性，但与此同时也会严重影响数据库的性能（事务执行时间 = 读取数据页时间 + DML时间 + 刷新<code>redo log</code>到磁盘时间）</p><p>如果对持久性要求不是很高的情况下，可以修改<code>innodb_flush_log_at_trx_commit</code>，该变量有三个可选值：</p><ol><li><code>0</code>: 事务提交以后，不会立刻把日志刷到磁盘里面，而是交给一个后台线程去做。这样一来请求的速度会快很多，但是这样就不能保证持久性了。</li><li><code>1</code>: 事务提交以后立马将日志刷到磁盘</li><li><code>2</code>: 事务提交以后，将<code>redo log</code>提交到<code>操作系统</code>缓冲区，并没有真正刷新到磁盘。这样可以在一定程度上保证持久性，只要操作系统没挂就没事。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><code>redo log</code>是为了保证持久性而生的</li><li><code>redo log</code>默认文件大小是<code>16M</code>（MySQL8.0），默认有两个日志文件</li><li><code>redo log</code>采用循环写的方式记录</li><li>如果发生追尾，那么就会强制刷盘，在此期间MySQL不接受外界的DML请求</li><li>可以通过修改<code>innodb_flush_log_at_trx_commit</code>来调整<code>redo log</code>刷盘机制</li></ol><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>在实际操作过程中，会出现这么一种情况：事务执行错了一条DML，这时候需要回退，之前的那些个DML操作根据原子性的要求，也应该回退，这个时候就需要<code>undo log</code>来救场了。</p><p>上述场景就像下棋一样，往左走了一步，要悔棋就应该向右走一步，回到原来的地方。如果要做一个类似悔棋的功能，那么势必需要保存上一步的位置才能够做到。<code>undo log</code>里面保存的就是修改前的状态。好比说<code>UPDATE</code>之前，值是3，<code>UPDATE</code>之后，值是2，那么MySQL会再执行<code>UPDATE</code>之前记录<code>undo log</code>，记录的值是3，也就是修改前的值。</p><h3 id="undo-log-类型"><a href="#undo-log-类型" class="headerlink" title="undo log 类型"></a>undo log 类型</h3><p><code>undo log</code>日志主要分为两种类型：</p><ol><li><code>INSERT UNDO LOG</code>: 记录<code>INSERT</code>操作的<code>undo log</code></li><li><code>UPDATE UNDO LOG</code>: 记录<code>UPDATE</code>操作的<code>undo log</code>，<code>UPDATE</code>包括了<code>update</code>和<code>delete</code></li></ol><h4 id="INSERT类型的undo-log"><a href="#INSERT类型的undo-log" class="headerlink" title="INSERT类型的undo log"></a>INSERT类型的undo log</h4><p>MySQL中，Insert类型的<code>undo log</code>采用<code>TRX_UNDO_INSERT_REC</code>类型的<code>undo log</code>来存储，每插入一条记录，就会生成一条<code>undo log</code>，而这条记录的<code>roll_pointer</code>隐藏列就会指向这个<code>undo log</code>，当需要回滚的时候，根据<code>undo log</code>就能找到这条插入的记录，然后删除掉就能够恢复到原来的样子了。</p><h4 id="UPDATE类型的undo-log"><a href="#UPDATE类型的undo-log" class="headerlink" title="UPDATE类型的undo log"></a>UPDATE类型的undo log</h4><ol><li>不更新主键的UPDATE<ul><li>原地更新：如果修改后列的值和原来列的值占用的字节数是相等的，那么就会直接在原来的列上进行修改即可。</li><li>删除后重新创建：如果修改列的值和原来的不相等，那么就需要删除（真实的删除）原来的记录，然后插入一条新的记录</li></ul></li><li>更新主键的UPDATE<ul><li>更新主键比较麻烦，因为MySQL的聚簇索引和非聚簇索引底层都是通过主键进行排序的，如果更新了主键，那么索引变动起来非常的麻烦，因此此时首先要对原来的就做<code>delete mark</code>（不是真实的删除，因为此时有可能有其他的事务在访问这条记录），然后再插入一条新的记录。</li></ul></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li><code>undo log</code>的目的是为了实现数据回滚，保证事务的原子性</li><li><code>undo log</code>记录的是修改前的状态，而且是在修改之前进行记录</li></ol><h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p>MySQL中的<code>bin log</code>区别于<code>redo log</code>和<code>undo log</code>，是一种二进制日志，其主要目的是为了：</p><ol><li>复制：搭建主从以后，通过<code>bin log</code>实现主服务器和从服务器之间的数据同步</li><li>数据恢复：数据库被删了，还可以通过<code>bin log</code>来恢复</li><li>增量备份</li></ol><h3 id="bin-log相关操作"><a href="#bin-log相关操作" class="headerlink" title="bin log相关操作"></a>bin log相关操作</h3><ol><li><p>查看<code>bin log</code>的存放目录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------------------+------------------------------------------+</span></span><br><span class="line">| Variable_name                   | Value                                    |</span><br><span class="line">+<span class="comment">---------------------------------+------------------------------------------+</span></span><br><span class="line">| log_bin                         | ON                                       |</span><br><span class="line">| log_bin_basename                | C:\Program Files\MySQL\Data\binlog       |</span><br><span class="line">| log_bin_index                   | C:\Program Files\MySQL\Data\binlog.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                                      |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                                      |</span><br><span class="line">| sql_log_bin                     | ON                                       |</span><br><span class="line">+<span class="comment">---------------------------------+------------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>查看<code>bin log</code>的状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| binlog.000047 |      155 |              |                  |                   |</span><br><span class="line">+<span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>清空<code>bin log</code>文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="error-log"><a href="#error-log" class="headerlink" title="error log"></a>error log</h2><p>MySQL使用过程中，总会遇到一些错误（最常见的就是SQL写错了这种），这些错误会被记录到<code>error log</code>中。</p><p>可以使用<code>--log-error[=file_name]</code>的方式来开启<code>error log</code>，如果<code>file_name</code>缺省，那么默认使用<code>hostname</code></p><p>可以通过<code>show variables like &#39;log_error&#39;;</code>查看<code>error log</code>日志清空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+-------------------------------------------------+</span></span><br><span class="line">| Variable_name | Value                                           |</span><br><span class="line">+<span class="comment">---------------+-------------------------------------------------+</span></span><br><span class="line">| log_error     | C:\Program Files\MySQL\Data\DESKTOP-4QRSVC9.err |</span><br><span class="line">+<span class="comment">---------------+-------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h2 id="slow-query-log"><a href="#slow-query-log" class="headerlink" title="slow query log"></a>slow query log</h2><p>慢查询日志主要是用于记录执行时间超过指定最长时间的SQL语句的一种日志，和该日志相关的配置项是：</p><ol><li><code>slow_query_log</code>: 是否开启慢查询日志</li><li><code>slow_query_log_file</code>: 慢查询日志文件名称</li><li><code>long_query_time</code>: 慢查询时间阈值，超过该值的查询SQL会被记录下来</li><li><code>min_examined_row_limit</code>: 如果查询的记录数少于这个值，即便超时了也不会被记录</li><li><code>log_queries_not_using_indexes</code>: 设置没有使用索引的SQL是否需要被记录</li></ol><h3 id="查看慢查询日志的内容"><a href="#查看慢查询日志的内容" class="headerlink" title="查看慢查询日志的内容"></a>查看慢查询日志的内容</h3><p>打开慢查询日志文件，其中一条记录是这样的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: 2020-10-18T18:55:20.823837Z  </span></span><br><span class="line"><span class="comment"># User@Host: root[root] @ localhost []  Id:     7  </span></span><br><span class="line"><span class="comment"># Query_time: 2.898604  Lock_time: 0.000295 Rows_sent: 2700216  Rows_examined: 300033  </span></span><br><span class="line"><span class="keyword">use</span> emp;  </span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">timestamp</span>=<span class="number">1603018520</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> demo_talbe;</span><br></pre></td></tr></table></figure><h2 id="general-log"><a href="#general-log" class="headerlink" title="general log"></a>general log</h2><p>前面讲到的日志类型如<code>redo log</code>、<code>undo log</code>、<code>bin log</code>、<code>error log</code>和<code>slow query log</code>，涵盖了查询、修改、错误信息、启动信息等所有内容，但是问题在于记录的不是很全面，而<code>slow query log</code>虽然很全面，但也只针对慢查询日志，MySQL中的<code>general log</code>记录了所有的操作日志，不过一般会消耗<code>5% - 10%</code>的性能，一般没事不会去开启。</p><h2 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h2><blockquote><p>The relay log, like the binary log, consists of a set of numbered files containing events that describe database changes, and an index file that contains the names of all used relay log files.</p><p>The term “relay log file” generally denotes an individual numbered file containing database events. The term”relay log” collectively denotes the set of numbered relay log files plus the index file</p></blockquote><p><code>relay log</code>和<code>bin log</code>很类似，都包含了数据库变更的记录，区别在于: <code>bin log</code>是主服务器记录下来的一些数据库变更，而<code>relay log</code>是从服务器从主服务器通过<code>I/O</code>复制过来的一份数据，然后从服务器通过读取<code>relay log</code>来完成和主服务器之间的数据同步。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INSERT INTO SELECT...加锁</title>
      <link href="2020/10/12/2e64bb50.html"/>
      <url>2020/10/12/2e64bb50.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>说出来可能不信，今晚上因为洗数据的问题，经理对我发出灵魂拷问。</p><blockquote><p>为什么要采用<code>rename</code>表的方式来做？你不知道<code>rename</code>是会锁表的吗？这段时间服务不可用怎么办？为什么不用<code>INSERT INTO SELECT...</code>来做？</p></blockquote><p>当时被问得心里比较慌，依稀记得看过一篇文章写到了<code>INSERT INTO SELECT...</code>如果不采用索引也会有锁表的问题，而这个洗数据的过程的WHERE条件里面就没有用到索引，只是当时没有想起来，被问的一愣一愣的，有些语无伦次，太丢脸了😂</p><p>当时考虑的还是比较简单，经理是希望我可以想的更有深度一些，考虑的更全面一点，意识还是要培养起来。</p><h2 id="INSERT-INTO-SELECT…"><a href="#INSERT-INTO-SELECT…" class="headerlink" title="INSERT INTO SELECT…"></a>INSERT INTO SELECT…</h2><p>之前看过的文章是《<a href="https://juejin.im/post/6844904086173646862">Insert into select语句引发的生产事故</a>》，看这篇文章也可以理解<code>INSERT INTO SELECT...</code>加锁的问题。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><blockquote><p>由于代码问题，第三方有一个循环插入数据到表<code>dirty_table</code>里面，导致短时间内这个表就达到了几百万的数据量，关键是还没有建索引，然后查询特别慢，一次耗时5秒左右！于是下定决心要改变这种情况。</p><p>好不容易代码修复完了、有效的数据也迁移到<code>new_table</code>里面去了，接下来就是改改表名就好了，然后就…</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>目前我需要执行的SQL语句是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> dirty_table <span class="keyword">TO</span> dirty_table_old;</span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> new_table <span class="keyword">TO</span> dirty_table;</span><br><span class="line"><span class="comment">-- dirty_table不能直接删了，在new_table里面的数据并不是全部的，dirty_table此时还在不断的接收新的数据进来，需要做增量更新</span></span><br></pre></td></tr></table></figure><p>这种做法毫无疑问在RENAME期间整个和<code>dirty_table</code>相关的业务都要受到影响，经理希望找一种能够不影响业务的方法来做到数据的切换，经理的想法是这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dirty_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> new_table <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dirty_table <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>看上去好像没啥问题，甚至甩我几条街，但是脑子里依稀记得这么搞是有问题的。</p><p>由于WHERE条件里面的列没有加上索引，因此在整个过程中，会对<code>dirty_table</code>加表锁，对<code>new_table</code>逐行加锁，最终的效果和RENAME其实感觉都差不多了…</p><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>结论是有了，但是还需要实际操作来验证。</p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`dirty_table`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`new_table`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">chars = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&#x27;insert_into_select_simulation.sql&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="keyword">file</span>:</span><br><span class="line">    file.write(<span class="string">&#x27;INSERT INTO dirty_table (`c1`, `c2`) VALUES &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&#x27;insert_into_select_simulation.sql&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> <span class="keyword">file</span>:</span><br><span class="line">    <span class="keyword">max</span> = <span class="number">1000000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, <span class="keyword">max</span>):</span><br><span class="line">        file.write(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;, &#x27;&#123;1&#125;&#x27;),&quot;</span>.format(i, chars[i % <span class="keyword">len</span>(chars)]))</span><br><span class="line">    file.write(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;, &#x27;&#123;1&#125;&#x27;);&quot;</span>.format(<span class="keyword">max</span>, chars[<span class="keyword">max</span> % <span class="keyword">len</span>(chars)]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&#x27;insert.sql&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="keyword">file</span>:</span><br><span class="line">    <span class="keyword">start</span> = <span class="number">1000001</span></span><br><span class="line">    <span class="keyword">end</span> = <span class="number">1001001</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">start</span>, <span class="keyword">end</span>):</span><br><span class="line">        file.write(<span class="string">&quot;INSERT INTO dirty_table (`id`, `c1`, `c2`) VALUES (&#x27;&#123;0&#125;&#x27;, &#x27;&#123;1&#125;&#x27;, &#x27;&#123;2&#125;&#x27;);\n&quot;</span>.format(i, i, chars[i % <span class="keyword">len</span>(chars)]))</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据转移脚本</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dirty_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dirty_table <span class="keyword">WHERE</span> c1 &gt; <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 同时执行insert.sql里面的脚本，模拟此时有用户操作的情况</span></span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>先运行<code>INSERT INTO ... SELECT ...</code>语句，然后再运行<code>INSERT INTO ...</code>语句，模拟此时有用户在使用。</p><p>然后你会发现并没有如预期中那样被阻塞😂</p><p>一开始我也很懵逼，甚至有点慌（毕竟我后面还信誓旦旦去找我经理说这玩意也会锁表的😂）</p><p>然后开始翻资料，在<a href="https://www.percona.com/blog/2006/07/12/insert-into-select-performance-with-innodb-tables/">INSERT INTO … SELECT Performance with Innodb tables.</a>这篇文章里介绍了为什么会加锁。这篇文章的大致意思是：一般的<code>SELECT</code>预计是不会加锁的，除非显示的申明<code>IN SHARE MODE</code>或者<code>FOR UPDATE</code>，但是<code>INSERT INTO table1 SELECT * FORM table2</code>是个特例，因为这个时候会锁住表<code>table2</code>，其目的是为了防止在<code>SELECT</code>的时候有其他的事务更新数据导致复制的时候出现不一致的问题。不过这篇资料有点老了，是2008年的，而且写的时候用的好像是MySQL 5.1😂，不过道理还是对的。</p><p>然而还是没有找到为什么这里没有加锁的原因，于是又开始在Google的海洋里遨游，终于给我找到了<code>Stackover Flow</code>里面的一个问题：<a href="https://stackoverflow.com/questions/2640898/how-to-improve-insert-into-select-locking-behavior">How to improve INSERT INTO … SELECT locking behavior</a>，这位大佬的问题大致意思是他们公司有个<code>INSERT INTO ... SELECT ... </code>，然后定时的跑，他发现执行这个东西的时候其它查询涉及到的表的时候耗时很长，问问该怎么提升性能。下面的一个回答给我启发：</p><p>可以设置<code>binlog_format = ROWS</code></p><p>莫非我的这个设置不是ROWS？</p><p>赶紧查查</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%binlog_format%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201013231111.png"></p><p>果然如此，赶紧修改（这里还有查阅binlog_format的资料，但是由于篇幅问题就不展开讨论了，后续会专门对binlog_format进行深入的分析了解）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> binlog_format = <span class="keyword">STATEMENT</span>;</span><br></pre></td></tr></table></figure><p>我以为这样就万事大吉了，然而测试的时候还是没有出现预期中的情况，看来还有一些我没注意到的地方，继续Google😶</p><p>在<a href="https://cloud.tencent.com/developer/article/1639457">insert语句的加锁情况分析</a>中简单介绍了<code>innodb_autoinc_lock_mode</code>的三种模式，原来还需要修改这个东西。和<code>binlog_format</code>不同，这个需要到<code>my.cnf</code>里面修改，然后重新启动MySQL才能生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_autoinc_lock_mode%&#x27;</span></span><br></pre></td></tr></table></figure><p>到此，终于得到我预期的效果了，真的是太难了~</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201013224411.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从验证的过程中来看，MySQL（我的版本是8.0+的）默认的<code>binlog_format</code>、<code>innodb_autoinc_lock_mode</code>设置，可以保证在执行的时候不会锁全表，影响其它业务的正常运行，因此建议还是使用<code>INSERT INTO ... SELECT ... </code>而不是<code>RENAME</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://juejin.im/post/6844904086173646862">Insert into select语句引发的生产事故</a></li><li><a href="https://www.percona.com/blog/2006/07/12/insert-into-select-performance-with-innodb-tables/">INSERT INTO … SELECT Performance with Innodb tables.</a></li><li><a href="https://stackoverflow.com/questions/2640898/how-to-improve-insert-into-select-locking-behavior">How to improve INSERT INTO … SELECT locking behavior</a></li><li><a href="https://cloud.tencent.com/developer/article/1639457">insert语句的加锁情况分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的锁</title>
      <link href="2020/10/08/f312680c.html"/>
      <url>2020/10/08/f312680c.html</url>
      
        <content type="html"><![CDATA[<h2 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁/排他锁"></a>共享锁/排他锁</h2><p>共享锁也称为读锁，一个事务对某一行记录加了共享锁的情况下， 其它的事务也可以对这一行记录加共享锁，但是不可以加排他锁。</p><p>排他锁也称为写锁，一个事务对某一行加了排他锁的情况下，其他的事务不可以对这一行再加读锁或者写锁。</p><p>在查询时加上<code>IN SHARE MODE</code>可以获取共享锁，加上<code>LOCK FOR UPDATE</code>可以获取排他锁，需要注意的是，UPDATE、INSERT等语句会自动加上排他锁。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>在MySQL官网上关于行锁有这么一段话</p><blockquote><p>Record locks always lock index records, even if a table is defined with no indexes. For such cases, <code>InnoDB</code> creates a hidden clustered index and uses this index for record locking</p></blockquote><p>意思是，行锁一定是通过索引加上的，MySQL本身并没有实现行锁的方式，行锁是由存储引擎实现的，因此有的存储引擎支持行锁（例如InnoDB），有的不支持（例如MyISAM），行锁的一个优势是粒度小，并发高，缺点是实现复杂，开销大。</p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>在MySQL中会有这么一种情况，事务A对表T加了行锁，然后事务B对表T加了表锁。此时会出现一个驳论：事务A加了行锁的这一行仅允许事务A进行修改，事务B加了表锁，可以对表中的任意行进行修改。意向锁的目的就是为了让行锁和表锁共存。</p><p>当事务A要给某一行加行锁时，首先会给事务A获取一个该表的意向排他锁，然后才能够获取到这一行的行锁，当B事务要加表锁的时候，由于此时表上已经有了意向排他锁了，因此事务B加锁失败，被阻塞了。其整个过程是这样的：</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>SELECT … FOR UPDATE;<br />获取到意向排他锁（IX）、获取到排他锁（X）</td><td></td></tr><tr><td></td><td>LOCK TABLES ….;<br />阻塞，等待锁释放</td></tr><tr><td>commit;</td><td></td></tr><tr><td></td><td>获取表锁成功</td></tr></tbody></table><p>意向锁和其他锁的兼容情况：</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><div class="note info simple"><p>需要注意的是，意向锁一定是表级锁</p></div><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>MySQL对间隙锁的定义是这样的：</p><blockquote><p>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record. For example, <code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> prevents other transactions from inserting a value of <code>15</code> into column <code>t.c1</code>, whether or not there was already any such value in the column, because the gaps between all existing values in the range are locked.</p></blockquote><p>这段话说明：</p><ol><li>间隙锁一定是一个开区间</li><li>间隙锁会防止其它事务插入间隙区间内的值</li></ol><p>另一段说明是这样的：</p><blockquote><p>Gap locks in <code>InnoDB</code> are “purely inhibitive”, which means that their only purpose is to prevent other transactions from inserting to the gap. Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.</p></blockquote><p>这段话的意思是，不同的事务同一个间隙锁并不会冲突，甚至有包含关系也没事。</p><p>还有一段说明是这样的：</p><blockquote><p>There are also other effects of using the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a> isolation level. Record locks for nonmatching rows are released after MySQL has evaluated the <code>WHERE</code> condition. For <code>UPDATE</code> statements, <code>InnoDB</code> does a “semi-consistent” read, such that it returns the latest committed version to MySQL so that MySQL can determine whether the row matches the <code>WHERE</code> condition of the <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a>.</p></blockquote><p>这段话的意思是，在低于或等于读已提交的隔离级别下，间隙锁是无效的，因为这种隔离级别总会读取到最新的数据。</p><p>综上所述：</p><ol><li>间隙锁锁定的是一个开区间</li><li>其他事务不可以向间隙锁区间内插入值</li><li>多个事务可以获取同一个间隙锁</li><li>间隙锁只在可重复读的情况下生效（串行化没有必要了）</li></ol><h3 id="间隙锁测试"><a href="#间隙锁测试" class="headerlink" title="间隙锁测试"></a>间隙锁测试</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_lock_test`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sql&gt; SELECT * FROM t_lock_test;</span><br><span class="line">+<span class="comment">---+---+</span></span><br><span class="line">| a | b |</span><br><span class="line">+<span class="comment">---+---+</span></span><br><span class="line">| 0 | a |</span><br><span class="line">| 3 | c |</span><br><span class="line">| 5 | d |</span><br><span class="line">| 6 | g |</span><br><span class="line">+<span class="comment">---+---+</span></span><br></pre></td></tr></table></figure><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><h4 id="按照主键索引加间隙锁"><a href="#按照主键索引加间隙锁" class="headerlink" title="按照主键索引加间隙锁"></a>按照主键索引加间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> a = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h4 id="按照主键索引范围加间隙锁"><a href="#按照主键索引范围加间隙锁" class="headerlink" title="按照主键索引范围加间隙锁"></a>按照主键索引范围加间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;h&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h4 id="锁住不存在的数据"><a href="#锁住不存在的数据" class="headerlink" title="锁住不存在的数据"></a>锁住不存在的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> a = <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;m&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;h&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h4 id="按照非主键索引加间隙锁"><a href="#按照非主键索引加间隙锁" class="headerlink" title="按照非主键索引加间隙锁"></a>按照非主键索引加间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_lock_test <span class="keyword">WHERE</span> b = <span class="string">&#x27;c&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_lock_test <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">-- 失败</span></span><br></pre></td></tr></table></figure><h3 id="判断间隙锁的范围"><a href="#判断间隙锁的范围" class="headerlink" title="判断间隙锁的范围"></a>判断间隙锁的范围</h3><p>从上述例子中，不难看出间隙锁的范围，以按照为主键索引加间隙锁为例</p><p>其范围区间可以划分为</p><p><code>(-∞, a) -- (a, c) -- (c, d)</code></p><p>由于非聚簇索引的特性，如果非聚簇索引相同的话，就会按照主键索引进行排序，因此实际上根据索引结构来划分的话，其锁定的区间应该是这样的</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201011214945.png"></p><p>在这个范围内插入值都会被锁定</p><h3 id="间隙锁总结"><a href="#间隙锁总结" class="headerlink" title="间隙锁总结"></a>间隙锁总结</h3><p>从上述的几个例子中不难看出间隙锁的几个特性：</p><ol><li>按照主键索引不不会加间隙锁</li><li>按照主键索引范围或者锁住不存在的值的时候才会加间隙锁</li><li>按照非主键索引一定会加间隙锁</li><li>还有一点没有在测试中展现，主键索引和唯一索引的效果是一样的</li></ol><h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><p>MySQL对临键锁的定义是这样的</p><blockquote><p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p></blockquote><p>大致的意思就是，临键锁是行锁和间隙锁的一种组合，临键锁不仅要锁住索引行，还要锁住范围区间，可以看作是一个特殊的间隙锁</p><p>MySQL对临键锁还有一个比较重要的描述</p><blockquote><p>By default, <code>InnoDB</code> operates in <code>REPEATABLE READ</code> transaction isolation level. In this case, <code>InnoDB</code> uses next-key locks for searches and index scans, which prevents phantom rows </p></blockquote><p>InnoDB在可重复读这种隔离级别下，是通过临键锁来进行搜索和索引扫描的，这样的一个好处是可以在一定程度上防止幻读的出现。防止幻读的原理很简单，因为锁的是一个区间，如果要在这个区间里面插入值，那么是会阻塞的，而之所以说是在一定程度上，那是因为首先需要加锁，如果采用的是普通的<code>SELECT</code>而不是<code>SELECT ... IN SHARE MODE</code>或者<code>SELECT ... FOR UPDATE</code>，那么MySQL采用的还是快照读，并不会加锁。</p><h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><p>MySQL对插入意向锁的描述是这样的：</p><blockquote><p>An insert intention lock is a type of gap lock set by <a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a> operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</p></blockquote><p>这段话的大意是这样的：插入意向锁是一种<code>间隙锁</code>，插入意向锁的目的是在多个事务并发插入的时候，有可能这些事务插入的不是同一个地方，为了避免互相等待而弄出来的东西。</p><p>总结归纳一下插入意向锁：</p><ol><li>是一个间隙锁</li><li>和间隙锁不同的地方是，插入意向锁锁定的区间是一条记录，而不是一个范围</li><li>插入意向锁的目的是为了提升并发插入的效率</li></ol><h2 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h2><p>还是先来一段MySQL官方的描述</p><blockquote><p>An <code>AUTO-INC</code> lock is a special table-level lock taken by transactions inserting into tables with <code>AUTO_INCREMENT</code> columns. In the simplest case, if one transaction is inserting values into the table, any other transactions must wait to do their own inserts into that table, so that rows inserted by the first transaction receive consecutive primary key values.</p></blockquote><p>MySQL数据库里面字段实可以设置自增的，这些自增的字段在并发的情况下保证不会出现数据安全问题，全靠自增锁维持，在往自增字段里面插入值的时候，会加一个自增锁，这个锁是<span style="color:red;">表锁</span>，所以其它的事务在插入的时候，只能等待前面那个获取到自增锁的事务弄好了才能往里面插入。这就是为什么使用MySQL的主键自增策略会有瓶颈问题的原因所在。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL官网</a></li><li><a href="https://blog.csdn.net/Saintyyu/article/details/91269087">MySQL常见的七种锁详细介绍</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL JOIN执行细节</title>
      <link href="2020/10/08/1ceae895.html"/>
      <url>2020/10/08/1ceae895.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然间看到这一篇博客《<a href="https://segmentfault.com/a/1190000015572505">Mysql - JOIN详解</a>》，其中有一部分是对联表过程的描述，这段描述看完以后感觉怪怪的，如下:</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://i.loli.net/2020/10/08/ucHMS5lYomRaDbi.png" alt="3__8CHW8T~ZITUX9MYVE_@T.png"></p><p>如果两个表的数据量都在百万级别，那么照这个说法，先来一次笛卡尔积，得到的<code>vt1</code>表将是十万亿+级别的，这直接就可以把内存搞炸了吧……</p><p>之后看了其它的博客和官方文档以后，JOIN是通过两种算法<code>Nested-Loop Join</code>和<code>Block Nested-Loop Join</code>实现的</p><h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested-Loop Join"></a>Nested-Loop Join</h2><p>当ON条件使用索引时，采用的是<code>Nested-Loop Join</code>算法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_student.*, t_score.* <span class="keyword">FROM</span> t_student <span class="keyword">JOIN</span> t_score <span class="keyword">ON</span> t_student.stu_id = t_score.stu_id <span class="keyword">WHERE</span> t_student.stu_id = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>假设在<code>stu_id</code>上加了索引，那么这个JOIN的过程是这样的（假设以<code>t_student</code>做驱动表）：</p><ol><li><p>根据条件<code>t_student.stu_id = &#39;1&#39;</code>从<code>t_student</code>中获取对应的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_student</code>的数据</p></li><li><p>根据这一行数据的<code>stu_id</code>与<code>t_score</code>关联，获取<code>t_score</code>的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_score</code>的数据</p></li><li><p>将两行数据组成一条完整的结果，存入<code>NET BUFFER</code>中</p></li><li><p>重复上述过程，直到<code>t_student</code>没有满足条件的行为止</p></li></ol><p>从上述的描述中可以看出，要查询出数据每次都要进行回表操作，而回表操作是随机IO，性能上面肯定不行。MySQL对这一步做了一些优化，操作系统读取数据的时候，不是指定了<code>id=xxx</code>就只会给你读这一条数据出来，而是一次加载一页的数据，也就是这条数据周边的其它数据也一起加载进来了。基于此，在第2步和第4步的时候，不会立刻去回表查询，而是先存入<code>read_md_buffer</code>，按照主键排序以后，再去回表查询，这样有可能下一条需要查询的数据在上一次查询的时候已经加载进内存了，节省了IO的次数。</p><h2 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h2><p>如果没有使用索引的话，那么就在只能做全表扫描了，还是原来的SQL，仍然假设<code>t_student</code>做驱动表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_student.*, t_score.* <span class="keyword">FROM</span> t_student <span class="keyword">JOIN</span> t_score <span class="keyword">ON</span> t_student.stu_id = t_score.stu_id <span class="keyword">WHERE</span> t_student.stu_id = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><ol><li><p>根据条件<code>t_student.stu_id = &#39;1&#39;</code>从<code>t_student</code>中获取对应的主键</p></li><li><p>根据上一步获取的主键回表获取<code>t_student</code>的数据，放入<code>JOIN BUFFER</code></p></li><li><p>再根据<code>JOIN BUFFER</code>中的数据，根据ON条件对<code>t_score</code>做全表扫描，找出符合条件的值</p></li><li><p>如果<code>t_student</code>表的数据没有扫描完，清空<code>JOIN BUFFER</code>，继续扫描<code>t_student</code>，重复</p></li></ol><h2 id="驱动表为什么一定是小表"><a href="#驱动表为什么一定是小表" class="headerlink" title="驱动表为什么一定是小表"></a>驱动表为什么一定是小表</h2><div class="note info simple"><p>暂且忽略可能的回表操作</p></div><p>MySQL JOIN的情况分为使用了索引和未使用索引这两种情况，假设驱动表行数为N，被驱动表行数为M</p><ol><li>使用索引的情况<ul><li>首先对驱动表根据条件做一次全表扫描，扫描行数为N</li><li>接着根据索引查询被驱动表，扫描行数为$N * \log_2M$</li><li>总的次数为$N + N * \log_2M$</li></ul></li><li>不适用索引的情况<ul><li>假设驱动表分段放入JOIN BUFFER需要分成K段，$K = \lambda * N$</li><li>总的扫描次数是$N + \lambda * N * M$</li></ul></li></ol><p>从上述两种情况来看，N或者M越小，扫描次数就越少，效率也就越高。减小N对于减小次数的幅度会比减小M的更大一些，因此驱动表选择小表更合适</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000015572505">Mysql - JOIN详解</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html">MySQL官网</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题</title>
      <link href="2020/10/08/af355a99.html"/>
      <url>2020/10/08/af355a99.html</url>
      
        <content type="html"><![CDATA[<h2 id="0001-两数之和"><a href="#0001-两数之和" class="headerlink" title="0001 两数之和"></a>0001 两数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><div class="tabs" id="0001"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0001-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0001-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0001-1"><p>最简单的方法就是两层循环遍历，直到找到符合条件的组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">int</span> n2 = target - n1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == n2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0001-2"><p>第一种做法显然会比较耗时一点，其耗时主要体现在需要重复的去寻找匹配的值，这个值可能是不存在的，那么这里就要做一次无用功。为了节省这一部分时间，可以将值全部通过hash散列存储起来，之后查找的时候就可以在O(1)时间复杂度内找到对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">int</span> n2 = target - n1;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(n2)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0002-两数相加"><a href="#0002-两数相加" class="headerlink" title="0002 两数相加"></a>0002 两数相加</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001141.svg" /></div><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><div class="tabs" id="0002"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0002-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0002-1"><p>很简单的一个链表相加的算式，唯一需要注意的地方是最后的结果可能有进位需要单独处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p1 = l1, p2 = l2, curr = res;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> || p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = p1 == <span class="keyword">null</span> ? <span class="number">0</span> : p1.val;</span><br><span class="line">        <span class="keyword">int</span> val2 = p2 == <span class="keyword">null</span> ? <span class="number">0</span> : p2.val;</span><br><span class="line">        p1 = p1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : p1.next;</span><br><span class="line">        p2 = p2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : p2.next;</span><br><span class="line">        <span class="keyword">int</span> sum = flag + val1 + val2;</span><br><span class="line">        flag = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0004-寻找两个正序数组的中位数"><a href="#0004-寻找两个正序数组的中位数" class="headerlink" title="0004 寻找两个正序数组的中位数"></a>0004 寻找两个正序数组的中位数</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><p>示例 1：</p><blockquote><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000</p></blockquote><p>示例 4：</p><blockquote><p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000</p></blockquote><p>示例 5：</p><blockquote><p>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p></blockquote><div class="note info simple"><p>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p></div><div class="tabs" id="0004"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0004-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0004-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0004-1"><p>最简单的就是合并两个数组了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = merge(nums1, nums2);</span><br><span class="line">    <span class="keyword">if</span> (nums.length % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>] / <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (nums[nums.length / <span class="number">2</span>] + nums[nums.length / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] mergeArr = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + nums2.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            mergeArr[index++] = nums1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeArr[index++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length) &#123;</span><br><span class="line">        mergeArr[index++] = nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums2.length) &#123;</span><br><span class="line">        mergeArr[index++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0004-2"><p>其实并不需要合并两个数组，他们本身是有序的，如果总的长度是奇数，那么只要找到中间那个就好，否则找到中间那两个。实际上就是比较小的数丢掉<code>len / 2</code>个，然后取<code>len / 2 + 1</code>或者后面两个数的平均数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length, len2 = nums2.length, len = len1 + len2;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt;= len / <span class="number">2</span>; index++) &#123;</span><br><span class="line">        left = right;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1 &amp;&amp; (j &gt;= len2 || nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">            right = nums1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0011-盛最多水的容器"><a href="#0011-盛最多水的容器" class="headerlink" title="0011 盛最多水的容器"></a>0011 盛最多水的容器</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p> <img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例：</p><blockquote><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p></blockquote><div class="tabs" id="0004"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0004-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0004-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0004-1"><p>很简单的思路，两个左右指针不断地向中间靠拢，此时他们的距离一定会缩短，为了保证容量有可能是在增大的，因此他们两个指针的最小的那个向前移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">        res = Math.max(res, temp);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0004-2"><p>解法2是对解法1的一次优化，解法1有一些不必要的尝试，例如如果小的那个指针向前移动以后，高度比原来的还小，那么这个是没有必要去计算的，因为宽度已经变小了，高度再变小只会比原来的更小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> minWidth = Math.min(height[left], height[right]);</span><br><span class="line">        <span class="keyword">int</span> temp = minWidth * (right - left);</span><br><span class="line">        res = Math.max(res, temp);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; height[left] &lt;= minWidth) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; height[right] &lt;= minWidth) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0015-三数之和"><a href="#0015-三数之和" class="headerlink" title="0015 三数之和"></a>0015 三数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><blockquote><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><div class="tabs" id="0015"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0015-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0015-2"><i class="fas fa-pen"></i>解法2</button></li><li class="tab"><button type="button" data-href="#0015-3"><i class="fas fa-pen"></i>解法3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0015-1"><p>最最简单的一个方法就是，直接三层循环去搜索就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = j + <span class="number">1</span>; h &lt; nums.length; h++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (h &gt; j + <span class="number">1</span> &amp;&amp; nums[h - <span class="number">1</span>] == nums[h]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[h] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[h]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0015-2"><p>其实也比较简单，比较关键的一步是要先对这个数组排序，然后还要注意的就是不要有重复的组合出现，做到不重复也简单，只要新的组合开头不是之前出现过的那个元素就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    findThreeNumsSum(nums, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findThreeNumsSum</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp, <span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.size() == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index) &#123;</span><br><span class="line">            <span class="comment">// 避免重复</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        findThreeNumsSum(nums, res, temp, i + <span class="number">1</span>, target + nums[i]);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0015-3"><p>前面两种方式都是不能通过的，超出了时间限制。其实前面两种方式的核心思想都是一个一个的去尝试，但是这是完全没有必要的，前面两种方式都有一个共同的地方：对数组进行了排序，这个很重要，说明数组是有序的，这样的话其实可以将问题简化为 ：确定了某一个数，求另外两个数的和为某一个数的组合，这不就又回到了两数之和的场景了吗？之前的两数之和因为是无序的，所以用了额外的存储空间记录位置信息，而此时是有序的，那么就完全可以使用双指针的方式找到指定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++l]) &#123;&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r]) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0016-最接近的三数之和"><a href="#0016-最接近的三数之和" class="headerlink" title="0016 最接近的三数之和"></a>0016 最接近的三数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><div class="tabs" id="0016"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0016-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0016-1"><p>和题目 <a href="#0015">0015</a> 一样，思路都是一样的，只不过换了一个模式而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> minDis = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> dis = sum - target;</span><br><span class="line">            <span class="keyword">if</span> (dis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left - <span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right + <span class="number">1</span>] == nums[right]) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(dis) &lt; minDis) &#123;</span><br><span class="line">                minDis = Math.abs(dis);</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0018-四数之和"><a href="#0018-四数之和" class="headerlink" title="0018 四数之和"></a>0018 四数之和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p><strong>答案中不可以包含重复的四元组。</strong></p><p>示例：</p><blockquote><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p></blockquote><div class="tabs" id="0018"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0018-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0018-2"><i class="fas fa-pen"></i>解法2</button></li><li class="tab"><button type="button" data-href="#0018-3"><i class="fas fa-pen"></i>解法3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0018-1"><p>前面经历了两数之和、三数之和、最接近的三数之和之后，到了现在一些基本的套路总是要会了😂</p><p>还是参考三数之和的做法，双层循环直接怼上去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[--right] == nums[right + <span class="number">1</span>]) &#123;&#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[++left] == nums[left - <span class="number">1</span>]) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0018-2"><p>当然也可以使用DFS的方式来解决这道题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    findRes(nums, target, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findRes</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.size() == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        findRes(nums, target - nums[i], i + <span class="number">1</span>, res, temp);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无情超时😂</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0018-3"><p>看看别人的做法，我丢，原来还可以这样剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min1 = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (min1 &gt; target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max1 = nums[i] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (max1 &lt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min2 = nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (min2 &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> max2 = nums[i] + nums[j] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (max2 &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[--right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[++left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0026-删除排序数组中的重复项"><a href="#0026-删除排序数组中的重复项" class="headerlink" title="0026 删除排序数组中的重复项"></a>0026 删除排序数组中的重复项</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><blockquote><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><div class="tabs" id="0026"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0026-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0026-1"><p>题目很简单，一个很容易想到的方法就是，弄一个额外的数组出来，然后把全部的不重复的值放到这个额外的数组里面去，然后覆盖掉原来的数组即可，这种方法太简单了。</p><p>另一个方法就是直接在原有的基础上进行修改，两个指针<code>p1</code>、<code>p2</code>，<code>p1</code>代表新数组下一个不重复的元素的下标，<code>p2</code>代表就数组下一个不重复元素的下标，这么说意思就很明确了，就是用<code>p2</code>去找下一个不重复的元素，然后覆盖掉<code>p1</code>的位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums == <span class="keyword">null</span> ? <span class="number">0</span> : nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">1</span>, p2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; nums.length &amp;&amp; nums[p2] == nums[p2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2 &lt; nums.length &amp;&amp; nums[p2] != nums[p2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[p1++] = nums[p2++];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0027-移除元素"><a href="#0027-移除元素" class="headerlink" title="0027 移除元素"></a>0027 移除元素</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><blockquote><p>给定 nums = [3,2,2,3], val = 3,</p><p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>注意这五个元素可为任意顺序。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><div class="tabs" id="0026"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0026-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0026-1"><p>题目挺简单的，就不多解释了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; nums.length &amp;&amp; nums[p2] == val) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2 &lt; nums.length) &#123;</span><br><span class="line">            nums[p1++] = nums[p2++];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0031-下一个排列"><a href="#0031-下一个排列" class="headerlink" title="0031 下一个排列"></a>0031 下一个排列</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3 → 1,3,2</code><br><code>3,2,1 → 1,2,3</code><br><code>1,1,5 → 1,5,1</code></p><div class="tabs" id="0031"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0031-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0031-1"><p>主要的思路是这样的: </p><ol><li>首先这个要求是下一个排列是升序的，那么将两个数中前面的大数和前面的小数对调一下就好了，比如<code>1234</code>，将4和3对调一下就是<code>1243</code>，满足升序的排列就出来了</li><li>当然这边的下一个排列肯定说的是最小的那一个，那么这个时候对调的规则还是一样的<ol><li>首先找到第一个前面的数小于后面的数的数，记这个位置为<code>i</code>，此时<code>i</code>之后的数列是一个降序数列</li><li>然后从后往前找到第一个小于位置<code>i</code>的数，及这个位置为<code>j</code>，将这两个数对调位置</li><li>最后将<code>i ~ len</code>这一段数列进行反转即可</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt;= nums[i]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        swap(nums, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0033-搜索旋转排序数组"><a href="#0033-搜索旋转排序数组" class="headerlink" title="0033 搜索旋转排序数组"></a>0033 搜索旋转排序数组</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你一个升序排列的整数数组 nums ，和一个整数 target 。</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。</p><p>请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>示例 1：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1], target = 0<br>输出：-1</p></blockquote><div class="tabs" id="0033"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0033-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0033-1"><p>简单的暴力求解就不多说了，为了更加快一点，主要是运用到二分搜索的思想。</p><p>细心研究题目就会发现，找到数组的中点，不是左边有序就是右边有序。那么就可以将<code>target</code>和有序的那一边进行比较，如果在有序的里面，那么就搜索这个有序的，否则搜索无序的，如此一来，每次都会丢弃一半的数据，大大提高了查询的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 左边有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右边有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0034-在排序数组中查找元素第一个和最后一个出现的位置"><a href="#0034-在排序数组中查找元素第一个和最后一个出现的位置" class="headerlink" title="0034 在排序数组中查找元素第一个和最后一个出现的位置"></a>0034 在排序数组中查找元素第一个和最后一个出现的位置</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p></blockquote><div class="tabs" id="0034"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0034-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0034-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0034-1"><p>既然是排序的数组，那么就可以直接上二分搜索。根据二分搜索查找出来的一个位置，然后左右两边搜索找到第一个和最后一个位置就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = binarySearch(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = index, right = index;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length &amp;&amp; nums[right] == target) &#123;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[mid] &gt; target ? binarySearch(nums, target, left, mid - <span class="number">1</span>)</span><br><span class="line">                : binarySearch(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0034-2"><p>第一种解法很简单也很容易理解，事实上我们更希望的是可以直接 找到第一个和最后一个位置，而不是后面再去搜搜一次。</p><p><strong>找到第一个位置</strong></p><ol><li>如果找到的中点<code>nums[mid] == target</code>，那么这个<code>mid</code>可能是第一个位置也可能不是第一个位置，因此此时不是原来的二分搜索那样直接返回而是继续往左边找，即<code>right = mid - 1</code></li><li>如果此时<code>nums[mid] &gt; target</code>，那么就需要到<code>mid</code>的左边找，即<code>right = mid - 1</code></li><li>如果此时<code>nums[mid] &lt; target</code>，那么就需要到<code>mid</code>的右边找，即<code>left = mid + 1</code></li></ol><p><strong>找到最后一个位置</strong></p><p>和找到第一个位置唯一不同的地方在于第一步，如果此时找到的<code>mid</code>满足<code>nums[mid] == target</code>，那么这个位置可能是最后一个也可能不是，就需要到右边继续找，即<code>left = mid + 1</code>，之后的两步相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = findFirstPosition(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = findLastPosition(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirstPosition(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirstPosition(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirstPosition(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; left &lt; nums.length &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findLastPosition(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> findLastPosition(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findLastPosition(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; right &lt; nums.length &amp;&amp; nums[right] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0035-搜索插入位置"><a href="#0035-搜索插入位置" class="headerlink" title="0035 搜索插入位置"></a>0035 搜索插入位置</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><blockquote><p>输入: [1,3,5,6], 5<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: [1,3,5,6], 2<br>输出: 1</p></blockquote><p>示例 3:</p><blockquote><p>输入: [1,3,5,6], 7<br>输出: 4</p></blockquote><p>示例 4:</p><blockquote><p>输入: [1,3,5,6], 0<br>输出: 0</p></blockquote><div class="tabs" id="0035"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0035-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0035-1"><p>题目很简单，暴力循环就可以解决，但是当然不能用这么<code>low</code>的方法。既然数组是有序的，那么就可以怼二分搜索，这边通过二分搜索找到一个尽可能接近<code>target</code>的数就可以了。</p><ol><li>如果找到的<code>nums[mid] == target</code>，这个位置就是要插入的位置（不可能有重复的数据）</li><li>如果<code>nums[mid] &gt; target</code>，说明需要到左边去查找符合的数</li><li>如果<code>nums[mid] &lt; target</code>，那么就去右边找</li><li>最后非常重要的一点，<code>left &lt; right</code>而不是<code>lft &lt;= right</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] &gt;= target ? left : left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0039-组合总数"><a href="#0039-组合总数" class="headerlink" title="0039 组合总数"></a>0039 组合总数</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li><p>所有数字（包括 target）都是正整数。</p></li><li><p>解集不能包含重复的组合。 </p></li></ul><p>示例 1：</p><blockquote><p>输入：candidates = [2,3,6,7], target = 7,<br>所求解集为：<br>[<br>  [7],<br>  [2,2,3]<br>]</p></blockquote><p>示例 2：</p><blockquote><p>输入：candidates = [2,3,5], target = 8,<br>所求解集为：<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p></blockquote><div class="note info simple"><p>提示：</p><p>1 &lt;= candidates.length &lt;= 30<br>1 &lt;= candidates[i] &lt;= 200<br>candidate 中的每个元素都是独一无二的。<br>1 &lt;= target &lt;= 500</p></div><div class="tabs" id="0035"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0035-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0035-1"><p>题目很简单，直接用DFS就可以完美搞定。只需要认为是在不断的拼凑一个<code>targer</code>，不断地尝试就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    <span class="keyword">if</span> (candidates[<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        dfs(nums, target - nums[i], i, res, temp);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0040-组合总数II"><a href="#0040-组合总数II" class="headerlink" title="0040 组合总数II"></a>0040 组合总数II</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li><p>所有数字（包括目标数）都是正整数。</p></li><li><p>解集不能包含重复的组合。 </p></li></ul><p>示例 1:</p><blockquote><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p></blockquote><p>示例 2:</p><blockquote><p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p></blockquote><div class="tabs" id="0040"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0040-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0040-1"><p>和组合总数的思路是一样的，唯一的区别就是一个数只能用一次了，但是这个其实并不影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        dfs(nums, target - nums[i], i + <span class="number">1</span>, res, temp);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0041-缺失的第一个正数"><a href="#0041-缺失的第一个正数" class="headerlink" title="0041 缺失的第一个正数"></a>0041 缺失的第一个正数</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><p>示例 1:</p><blockquote><p>输入: [1,2,0]<br>输出: 3</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,4,-1,1]<br>输出: 2</p></blockquote><p>示例 3:</p><blockquote><p>输入: [7,8,9,11,12]<br>输出: 1</p></blockquote><div class="note info simple"><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p></div><div class="tabs" id="0041"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0041-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0041-1"><p>由于只能用到常数级别的空间复杂度，那么就只好复用原来的数组了，假如说在<code>i</code>位置的数为<code>nums[i]</code>，那么将对应位置的数变成负数，即<code>nums[nums[i] - 1] = -nums[nums[i - 1]]</code>，这就代表着，数字<code>nums[i]</code>出现过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = nums.length + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= nums.length) &#123;</span><br><span class="line">            nums[temp - <span class="number">1</span>] = -Math.abs(nums[temp - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0042-接雨水"><a href="#0042-接雨水" class="headerlink" title="0042 接雨水"></a>0042 接雨水</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"></p><blockquote><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p></blockquote><div class="tabs" id="0042"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0042-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0042-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0042-1"><p>这个题目其实也不难，对于某一列<code>i</code>，如果这个列能够积攒到雨水，那么必定存在左右两边的最高点都比<code>i</code>列大，所以这道题就变成了找到第<code>i</code>列和左右两边最高点的差，然后求和的题目了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>, min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            maxLeft = Math.max(maxLeft, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            maxRight = Math.max(maxRight, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        min = Math.min(maxLeft, maxRight);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; min) &#123;</span><br><span class="line">            res += min - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0042-2"><p>这个解法只是对解法1的优化，事实上可以不需要每次都去查找左右两边的最大值，完全可以保存下来的，这样就节省了很多的时间。</p><p>对于一个已知的列<code>i</code>而言，它的作边最大值要么就是他左边的那个值，要么就是上一个左边的最大值。</p><p>同理，对于已知列<code>i</code>而言，其右边的最大值要么是它右边的数，要么是上一个右边的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] maxLeft = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">int</span>[] maxRight = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        maxLeft[i] = Math.max(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxRight[i] = Math.max(maxRight[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(maxLeft[i], maxRight[i]);</span><br><span class="line">        <span class="keyword">if</span> (min &gt; height[i]) &#123;</span><br><span class="line">            res += min - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0045-跳跃游戏II"><a href="#0045-跳跃游戏II" class="headerlink" title="0045 跳跃游戏II"></a>0045 跳跃游戏II</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p><strong>示例：</strong></p><blockquote><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p></blockquote><p><strong>说明：</strong></p><p>假设你总是可以到达数组的最后一个位置。</p><div class="tabs" id="0045"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0045-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0045-2"><i class="fas fa-pen"></i>解法2</button></li><li class="tab"><button type="button" data-href="#0045-3"><i class="fas fa-pen"></i>解法3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0045-1"><p>第一个想法是：从最后一个元素开始，因为要走到最后一个位置嘛，那我就一个一个试呗，先看看前面一个能不能走到我这里来，再看看我前面的前面能不能走到我这里来…依次循环查找，最终超时了😂，不管怎么样也算是一个思路了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> minStep = dfs(nums, i, nums.length - i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        res = Math.min(res, minStep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> curr, <span class="keyword">int</span> minLen, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[curr] &gt;= minLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= curr; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minStep = dfs(nums, curr - i, i, step + <span class="number">1</span>);</span><br><span class="line">            res = Math.min(res, minStep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0045-2"><p>听说这种方法叫贪心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>, position = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                step++;</span><br><span class="line">                position = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0045-3"><p>实在不会，看看答案区的大神都是这么做的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPosition = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxPosition = Math.max(maxPosition, i + nums[i]); </span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPosition;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0048-旋转数组"><a href="#0048-旋转数组" class="headerlink" title="0048 旋转数组"></a>0048 旋转数组</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><blockquote><p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p></blockquote><div class="tabs" id="0045"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0045-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0045-1"><p>很简单，先求这个数组的转置，然后再把每行进行逆序就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">        reverse(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        swap(nums, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0053-最大子序和"><a href="#0053-最大子序和" class="headerlink" title="0053 最大子序和"></a>0053 最大子序和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><div class="tabs" id="0053"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0053-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0053-2"><i class="fas fa-pen"></i>解法2</button></li><li class="tab"><button type="button" data-href="#0053-3"><i class="fas fa-pen"></i>解法3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0053-1"><p>很简单，假设<code>i ~ j</code>是一个符合要求的连续子序列（此时该序列的和大于0），如果这个序列再加上下一个数<code>nums[k]</code>使得序列<code>i ~ k</code>的和为一个负数，那么序列<code>i ~ k</code>就绝对不可能成为最大子序列的一部分了，可以假设最大子序列<code>i ~ n</code>由<code>i ~ k</code> + <code>k + 1  ~ n</code>组成，既然<code>i ~ k</code>为一个负数，那么显然<code>k + 1 ~ n</code>会比<code>i ~ k</code>大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        temp = temp + nums[i];</span><br><span class="line">        res = Math.max(res, temp);</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0053-2"><p>还有一种动态规划的解法，假设<code>dp[i]</code>表示长度为<code>i + 1</code>的数组最大子序列的和，那么显然<code>dp[i] = Math.max(nums[i], nums[i] + dp[i - 1])</code>，根据这个式子可以写出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0053-3"><p>还有一种很有意思的分治算法，假设结果子序列是<code>i ~ j</code>，原来序列的中点是<code>mid</code>，那么这个子序列可以分为以下三种情况：</p><ol><li>子序列在原来序列的左边，即<code>j &lt; mid</code></li><li>子序列在原来序列的右边，即<code>i &gt; mid</code></li><li>子序列在原来序列的中间，即<code>i ~ j</code> =  <code>i ~ mid</code> + <code>mid + 1 ~ j</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMaxWithoutMid(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxWithoutMid</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">    <span class="keyword">int</span> leftSum = findMaxWithoutMid(nums, left, mid);</span><br><span class="line">    <span class="keyword">int</span> rightSum = findMaxWithoutMid(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> midSum = findMaxWithMid(nums, left, mid, right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(leftSum, midSum), rightSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxWithMid</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftSum = Integer.MIN_VALUE, rightSum = Integer.MIN_VALUE, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">        temp = temp + nums[i];</span><br><span class="line">        leftSum = Math.max(leftSum, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        temp = temp + nums[i];</span><br><span class="line">        rightSum = Math.max(rightSum, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0054-螺旋数组"><a href="#0054-螺旋数组" class="headerlink" title="0054 螺旋数组"></a>0054 螺旋数组</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><p><strong>示例 1:</strong></p><blockquote><p>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]</p><p>输出: [1,2,3,6,9,8,7,4,5]</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>输出: [1,2,3,4,8,12,11,10,9,5,6,7]</p></blockquote><div class="tabs" id="0054"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0054-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0054-1"><p>简单模拟就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m - <span class="number">1</span>, top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            res.add(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">            res.add(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt; left; i--) &#123;</span><br><span class="line">                res.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt; top; i--) &#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">        top++;</span><br><span class="line">        bottom--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0055-跳跃游戏"><a href="#0055-跳跃游戏" class="headerlink" title="0055 跳跃游戏"></a>0055 跳跃游戏</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><div class="tabs" id="0055"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0055-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0055-1"><p>之前已经做过类似的题目了…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxPos = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        maxPos = Math.max(maxPos, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            end = maxPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end &gt;= nums.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0056-合并区间"><a href="#0056-合并区间" class="headerlink" title="0056 合并区间"></a>0056 合并区间</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: intervals = [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><div class="tabs" id="0056"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0056-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0056-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0056-1"><p>先把数组排序，然后判断两个区间是否有重复，重复就覆盖结果的前一个元素，否则添加新的元素，模拟一遍就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span> || intervals[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    res.add(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preMin = res.get(index - <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> preMax = res.get(index - <span class="number">1</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> currMin = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> currMax = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (currMin &gt;= preMin &amp;&amp; currMin &lt;= preMax) &#123;</span><br><span class="line">            <span class="comment">// 重合</span></span><br><span class="line">            <span class="keyword">int</span> newMin = Math.min(preMin, currMin);</span><br><span class="line">            <span class="keyword">int</span> newMax = Math.max(preMax, currMax);</span><br><span class="line">            res.get(index - <span class="number">1</span>)[<span class="number">0</span>] = newMin;</span><br><span class="line">            res.get(index - <span class="number">1</span>)[<span class="number">1</span>] = newMax;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;currMin, currMax&#125;);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0056-2"><p>前一种直接模拟的方法只能是一种常规解法，还有大神的1ms解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = intervals[i][<span class="number">0</span>], r = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; intervals.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = intervals[j];</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= temp[<span class="number">1</span>] &amp;&amp; r &gt;= temp[<span class="number">0</span>]) &#123;</span><br><span class="line">                temp[<span class="number">0</span>] = Math.min(temp[<span class="number">0</span>], l);</span><br><span class="line">                temp[<span class="number">1</span>] = Math.max(temp[<span class="number">1</span>], r);</span><br><span class="line">                intervals[i] = <span class="keyword">null</span>;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans[--n] = interval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0057-插入区间"><a href="#0057-插入区间" class="headerlink" title="0057 插入区间"></a>0057 插入区间</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p>示例 1：</p><blockquote><p>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出：[[1,5],[6,9]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出：[[1,2],[3,10],[12,16]]<br>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p></blockquote><div class="tabs" id="0057"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0057-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0057-1"><p>算不上多难的题目把，简单的分类模拟一下就好了。</p><p>这里把<code>newIntervals</code>抽出来作为一个额外的插入区间存在，分为两种情况</p><ol><li>额外区间在当前区间的左边且没有交集，那么就先把额外区间加进去，然后加入当前区间</li><li>额外区间在当前区间的右边，直接把当前区间加进去就好了</li><li>有交集的情况，更新额外区间的最大、最小值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> left = newInterval[<span class="number">0</span>], right = newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left, right&#125;);</span><br><span class="line">                added = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">            res.add(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">            right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left, right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0059-螺旋矩阵-II"><a href="#0059-螺旋矩阵-II" class="headerlink" title="0059 螺旋矩阵 II"></a>0059 螺旋矩阵 II</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><blockquote><p>输入: 3<br>输出:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]</p></blockquote><div class="tabs" id="0059"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0059-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0059-1"><p>其实就是螺旋矩阵的逆过程而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>, bottom = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            res[top][i] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt; bottom; i++) &#123;</span><br><span class="line">            res[i][right] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--) &#123;</span><br><span class="line">                res[bottom][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt; top; i--) &#123;</span><br><span class="line">                res[i][left] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        bottom--;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0062-不同路径"><a href="#0062-不同路径" class="headerlink" title="0062 不同路径"></a>0062 不同路径</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt="img"></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><div class="tabs" id="0062"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0062-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0062-1"><p>简单dfs或者bfs都可以完成，但是太耗时了，而且也比较简单就没必要记录了。</p><p>由于机器人只能往右边或者下边走，所以对于第一行和第一列都只有一种到达的方法。而对其它任意一格<code>i, j</code>，这一个格子的走法要么从上面的一个格子下来，要么从左边过来，即<code>[i, j] = [i - 1][j] + [i][j - 1]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        res[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res[i][j] = res[i - <span class="number">1</span>][j] + res[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0063-不同路径-II"><a href="#0063-不同路径-II" class="headerlink" title="0063 不同路径 II"></a>0063 不同路径 II</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt="img"></p><p>示例 1：</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p><blockquote><p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br>示例 2：</li></ol><p>输入：obstacleGrid = [[0,1],[0,0]]<br>输出：1</p></blockquote><p><strong>示例 2：</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img"></p><blockquote><p>输入：obstacleGrid = [[0,1],[0,0]]<br>输出：1</p></blockquote><div class="tabs" id="0063"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0063-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0063-1"><p>和上一题的原理是一样的，只不过这里多了一个障碍物而已，那么这样一来就有</p><ol><li>第一行和第一列的走法仍然是1，但是如果出现了障碍物，那么障碍物及本身的走法都是0，因为不可能去到那边了</li><li>对于任意的<code>i, j</code>，如果是一个障碍物，那么走法是0，否则规则和上一个相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i][j] = res[i - <span class="number">1</span>][j] + res[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0064-最小路径和"><a href="#0064-最小路径和" class="headerlink" title="0064 最小路径和"></a>0064 最小路径和</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p><blockquote><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>示例 2：</p><blockquote><p>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p></blockquote><div class="tabs" id="0064"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0064-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0064-1"><p>思路和前面的《不同路径》是一模一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    res[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i] = res[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        res[i][<span class="number">0</span>] = res[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res[i][j] = Math.min(res[i - <span class="number">1</span>][j], res[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0066-加一"><a href="#0066-加一" class="headerlink" title="0066 加一"></a>0066 加一</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000711.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1：</p><blockquote><p>输入：digits = [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。</p></blockquote><p>示例 2：</p><blockquote><p>输入：digits = [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。</p></blockquote><p>示例 3：</p><blockquote><p>输入：digits = [0]<br>输出：[1]</p></blockquote><div class="tabs" id="0066"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0066-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0066-1"><p>题目不难，直接模拟就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    digits[digits.length - <span class="number">1</span>] = digits[digits.length - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = flag + digits[i];</span><br><span class="line">        flag = sum / <span class="number">10</span>;</span><br><span class="line">        res.add(sum % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0073-矩阵置零"><a href="#0073-矩阵置零" class="headerlink" title="0073 矩阵置零"></a>0073 矩阵置零</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><p>示例 1:</p><blockquote><p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]</p></blockquote><p>示例 2:</p><blockquote><p>输入:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>输出:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]</p></blockquote><div class="tabs" id="0073"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0073-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0073-1"><p>简单的做法就是，找到所有的0点，然后再把行和列置为零就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; zeroPoint = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroPoint.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] point : zeroPoint) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = point[<span class="number">0</span>], j = point[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 行置零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; n; h++) &#123;</span><br><span class="line">            matrix[i][h] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列置零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; m; h++) &#123;</span><br><span class="line">            matrix[h][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0074-搜索二维矩阵"><a href="#0074-搜索二维矩阵" class="headerlink" title="0074 搜索二维矩阵"></a>0074 搜索二维矩阵</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p><p>示例 1：</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p><blockquote><p>输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3<br>输出：true</p></blockquote><p>示例 2：</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" alt="img"></p><blockquote><p>输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 13<br>输出：false</p></blockquote><p>示例 3：</p><blockquote><p>输入：matrix = [], target = 0<br>输出：false</p></blockquote><div class="tabs" id="0074"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0074-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0074-1"><p>很明显的，这个二维数组的定义展开来其实也是一个有序的一维数组，那么完全就可以当作一个一维数组来处理了。</p><p>比如说这样的二维数组</p><blockquote><p>[</p><p>[1,3,5,7],</p><p>[10,11,16,20],</p><p>[23,30,34,60]</p><p>]</p><p>展开来其实就是</p><p>[1,3,5,7,10,11,16,20,23,30,34,60]</p><p>其长度为12</p><p>假如说按照二分的套路，第一次二分得到的mid是5，对应的就是数字11</p><p>这个16就是原来数组的第二行第二个</p><p>假如说target在左边，那么第二次二分得到的mid是2，对应的数字是5</p><p>也就是原来数组的第一行第三个</p><p>假设原二维数组为m * n的二维数组，那么二分得到的mid实际对应的就是</p><p><code>i = mid / n</code>, <code>j = mid % n</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">int</span> i = mid / n, j = mid % n;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0075-颜色分类"><a href="#0075-颜色分类" class="headerlink" title="0075 颜色分类"></a>0075 颜色分类</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><div class="note info simple"><p>不能使用代码库中的排序函数来解决这道题。</p></div><p>示例:</p><blockquote><p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p></blockquote><div class="tabs" id="0075"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0075-1"><i class="fas fa-pen"></i>解法1</button></li><li class="tab"><button type="button" data-href="#0075-2"><i class="fas fa-pen"></i>解法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0075-1"><p>最简单的方法不过排序了…..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> zeroNum = <span class="number">0</span>, oneNum = <span class="number">0</span>, twoNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            zeroNum++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            oneNum++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            twoNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (zeroNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">            zeroNum--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oneNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">            oneNum--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">            twoNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0075-2"><p>另一种解法就是，这里毕竟只有3个数，所以可以先把0全部放到第一位，然后把1放到第二位，最后剩下的就是排好序的2了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            swap(i, p, nums);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            swap(i, p, nums);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0078-子集"><a href="#0078-子集" class="headerlink" title="0078 子集"></a>0078 子集</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><blockquote><p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p></blockquote><div class="tabs" id="0078"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0078-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0078-1"><p>简单的dfs就可以搞定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dfs(nums, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line">        dfs(nums, i + <span class="number">1</span>, res, temp);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0079-单词搜索"><a href="#0079-单词搜索" class="headerlink" title="0079 单词搜索"></a>0079 单词搜索</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:</p><blockquote><p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p><p>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p></blockquote><div class="tabs" id="0079"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0079-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0079-1"><p>dfs不断地搜索~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer[][] DIRECTION = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span> || word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == words[<span class="number">0</span>]) &#123;</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">boolean</span> find = dfs(board, words, visited, m, n, <span class="number">1</span>, i, j);</span><br><span class="line">                visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (find) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == word.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer[] dirct : DIRECTION) &#123;</span><br><span class="line">        <span class="keyword">int</span> newX = x + dirct[<span class="number">0</span>], newY = y + dirct[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= m || newY &lt; <span class="number">0</span> || newY &gt;= n || board[newX][newY] != word[index] || visited[newX][newY]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[newX][newY] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> success = dfs(board, word, visited, m, n, index + <span class="number">1</span>, newX, newY);</span><br><span class="line">        visited[newX][newY] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0080-删除排序数组中的重复项-II"><a href="#0080-删除排序数组中的重复项-II" class="headerlink" title="0080 删除排序数组中的重复项 II"></a>0080 删除排序数组中的重复项 II</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定一个增序排列数组 nums ，你需要在 原地 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>说明：</p><div class="note info simple"><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下：</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p></div><p>示例 1：</p><blockquote><p>输入：nums = [1,1,1,2,2,3]<br>输出：5, nums = [1,1,2,2,3]<br>解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [0,0,1,1,1,1,2,3,3]<br>输出：7, nums = [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。</p></blockquote><div class="tabs" id="0080"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0080-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0080-1"><p>解法很简单，直接覆盖掉重复的元素就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            nums[p++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0081-搜索旋转排序数组-II"><a href="#0081-搜索旋转排序数组-II" class="headerlink" title="0081 搜索旋转排序数组 II"></a>0081 搜索旋转排序数组 II</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001002.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>示例 1:</p><blockquote><p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false</p></blockquote><p>进阶:</p><p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><div class="tabs" id="0081"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0081-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0081-1"><p>挺简单的一道题，核心思想仍然是二分法。</p><p>由于数组是有序的，所以旋转一次以后，总会有一边是有序的，那么就可以先判断这个有序的地方是不是包含target，是的话就在这边找，不是就舍弃到另外一边找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> search(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> search(nums, target, left, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> search(nums, target, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> search(nums, target, left + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="0084-柱状图中最大的矩形"><a href="#0084-柱状图中最大的矩形" class="headerlink" title="0084 柱状图中最大的矩形"></a>0084 柱状图中最大的矩形</h2><div class="leetcode">    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014001204.svg" />    <img style="float: left;" src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201014000748.svg" /></div><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> <img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p> <img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例:</p><blockquote><p>输入: [2,1,5,6,2,3]<br>输出: 10</p></blockquote><div class="tabs" id="0084"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0084-1"><i class="fas fa-pen"></i>解法1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0084-1"><p>这道题很简单，矩形面积就是长乘宽，在这个题目里面，长是确定的，而宽由最小的那个柱子决定。</p><p>这个题目应该从最高的那个柱子开始，不断地向两边扩展尝试，找到最大的那一个解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法实现</title>
      <link href="2020/10/08/9f76ab7a.html"/>
      <url>2020/10/08/9f76ab7a.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>雪花算法生成的id总共由64位组成，其每个部分如图所示：</p><p><img src= "https://cdn.jsdelivr.net/gh/longhujing/assert/img/20201007015211.gif" data-lazy-src="https://i.loli.net/2020/09/17/9Iaefb4S8EwNL3F.png" alt="13382703-b64e38457ddd13e2.png"></p><p><code>1bit</code>: 二进制中最高位是符号位，用于确定数值的正负，0代表正数，1代表负数。一般而言<code>id</code>都是正数，所以最高位这边的<code>0</code>一般是不会动的。</p><p><code>41bit</code>: 接下来的<code>41bit</code>用于记录时间戳（毫秒级），41位可以表示$2^{41} - 1$个数字，换算成年就是$(2^{41} - 1) / (1000 * 60 * 60 * 60 * 24 * 365) = 69$年</p><p><code>10bit</code>: 接下来的<code>10bit</code>用于区分不同的机器，因为系统可能不止一台机器，每一台机器生成<code>id</code>的时间戳有可能相同，因此需要标记不同的机器。<code>10bit</code>分<code>5bit</code>的<code>centerId</code>和<code>5bit</code>的<code>workerId</code>。</p><p><code>12bit</code>: 序列号是用来记录同一毫秒内产生的不同的id。一台机器有可能在同一毫秒内会产生多个id。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳 2020-01-01 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimeStamp = <span class="number">1577808000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id占据的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据表时id所占位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大支持的workerId 31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大支持的dataCenterId 31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDataCenterId = ~(-<span class="number">1L</span> &lt;&lt; dataCenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号所占位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识起始位置（从右往左数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳标识起始位置（从右往左数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStampShift = sequenceBits + workerIdBits + dataCenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号掩码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一次生成的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> dataCenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;WorkerId Can Not Greater Than %s Or Less Than 0&quot;</span>, workerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;DataCenterId Can Not Greater Than %s Or Less Than 0&quot;</span>, dataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个id 线程安全的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取的时间戳有精度缺失的问题</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = SystemClock.now();</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">// 有可能出现了系统时钟回退</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock Move Backwards, Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">// 同一毫秒，毫秒内序列化id</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 序列化耗尽，阻塞直到获取到下一个时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimeStamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新的毫秒值 重置序列号</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimeStamp = timestamp;</span><br><span class="line">        <span class="keyword">return</span> ((lastTimeStamp - startTimeStamp) &lt;&lt; timeStampShift)</span><br><span class="line">                | (dataCenterId &lt;&lt; dataCenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdBits)</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一毫秒，获取新的毫秒值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimeStamp 最后一次获取到毫秒值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个毫秒值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimeStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = -<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            timestamp = SystemClock.now();</span><br><span class="line">        &#125; <span class="keyword">while</span> (timestamp &lt;= lastTimeStamp);</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System.currentTimeMillis优化</title>
      <link href="2020/10/08/84d1ebba.html"/>
      <url>2020/10/08/84d1ebba.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前开发的时候经常使用<code>System.currentTimeMillis</code>来获取当前的时间戳，刚好解决雪花算法生成重复ID的时候看到了这个的优化，好奇之下对这个优化及进行了探索。</p><h2 id="System-currentTimeMillis为什么慢"><a href="#System-currentTimeMillis为什么慢" class="headerlink" title="System.currentTimeMillis为什么慢"></a>System.currentTimeMillis为什么慢</h2><p>为什么<code>System.currentTimeMillis</code>会耗时呢？有一篇<a href="https://pzemtsov.github.io/2017/07/23/the-slow-currenttimemillis.html">文章</a>对这个做了解释。简而言之就是：调用底层的获取时间戳的方法需要<strong>从用户态切换到内核态</strong>，而且这个获取时间戳的方法还受到Linux计时器的影响（Linux系统中只有一个计时器）如果并发访问的情况下，会出现资源争抢激烈的情况。</p><p>Linux计时器分为两种：HPET和TSC，HPET性能较差，因为HPET通过串行来处理并发请求，TSC性能稍好一点，会有专门的寄存器记录时间，缺点是稳定性不好，因为TSC是存硬件的计时器，频率可变。</p><p>在了解了<code>System.currentTimeMillis</code>为什么慢以后，接下来看看它到底有多慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> times = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System.currentTimeMillis 耗时: &quot;</span> + (end1 - start1) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成<code>10000</code>、<code>100000</code>、<code>1000000</code>分别耗时<code>4ms</code>、<code>6ms</code>、<code>10ms</code>，耗时还是比较长的。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p><code>System.currentTimeMillis</code>慢的原因是底层调用的系统级别的获取时间戳的方法，既然如此，那么我们就绕开系统底层，我们走内存。一个显而易见的方式是：第一次调用<code>System.currentTimeMillis</code>方法记录下这个时间戳，然后启动一个定时任务，每隔<code>1ms</code>去更新一下这个时间戳，当有需要获取这个时间戳的时候就直接从内存里面 拿现成的，而不用找系统获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停顿时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong now;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SystemClock</span><span class="params">(<span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.now = <span class="keyword">new</span> AtomicLong(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类持有 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SystemClock INSTANCE = <span class="keyword">new</span> SystemClock(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单线程定时轮询任务，每1毫秒更新一次时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleClockUpdating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">&quot;System Clock&quot;</span>);</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; now.set(System.currentTimeMillis()), period, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看时间对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> times = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = SystemClock.now();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System.currentTimeMillis 耗时: &quot;</span> + (end1 - start1) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;System Clock 耗时: &quot;</span> + (end2 - start2) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成<code>100000</code>、<code>1000000</code>、<code>10000000</code>、<code>100000000</code>个时间戳耗时对比</p><table><thead><tr><th>数量</th><th>System.currentTimeMillis</th><th>SystemClock</th></tr></thead><tbody><tr><td>100000</td><td>7ms</td><td>2ms</td></tr><tr><td>1000000</td><td>13ms</td><td>4ms</td></tr><tr><td>10000000</td><td>45ms</td><td>7ms</td></tr><tr><td>100000000</td><td>485ms</td><td>41ms</td></tr></tbody></table><p>可见在性能上，<code>SystemClock</code>确实强了很多。</p><h2 id="优化方案问题"><a href="#优化方案问题" class="headerlink" title="优化方案问题"></a>优化方案问题</h2><p>虽然优化后的方案在性能上比原来的传统方式快了很多，但是也有一个很明显的问题：<strong>精度缺失</strong>，新方案并不能保证每次获取到的时间戳都是最新的，因此很有可能多个线程获取到的时间戳是同一个时间戳。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
